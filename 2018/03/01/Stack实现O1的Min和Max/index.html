<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="在常数时间内获取栈的最大值和最小值，是算法设计中一个经典且有趣的问题。本文记录了从最直观的辅助栈方案，到利用差值存储的优化方案的推导过程。">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://www.yeqown.xyz/2018/03/01/Stack%E5%AE%9E%E7%8E%B0O1%E7%9A%84Min%E5%92%8CMax/">
  <meta property="og:site_name" content="Yeqown">
  <meta property="og:title" content="Stack实现O(1)的Min和Max：从空间换时间到数学魔法的探究">
  <meta property="og:description" content="在常数时间内获取栈的最大值和最小值，是算法设计中一个经典且有趣的问题。本文记录了从最直观的辅助栈方案，到利用差值存储的优化方案的推导过程。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2018-03-01T16:26:05+08:00">
    <meta property="article:modified_time" content="2018-03-01T16:26:05+08:00">
    <meta property="article:tag" content="Golang">
    <meta property="article:tag" content="Algorithm">
<title>Stack实现O(1)的Min和Max：从空间换时间到数学魔法的探究 | Yeqown</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="https://www.yeqown.xyz/2018/03/01/Stack%E5%AE%9E%E7%8E%B0O1%E7%9A%84Min%E5%92%8CMax/">
<link rel="stylesheet" href="/book.min.c2fbf3db843e2f212ac724c116ea0973ae0c44d9926b1c14e16b29de812a6dc5.css" integrity="sha256-wvvz24Q&#43;LyEqxyTBFuoJc64MRNmSaxwU4Wsp3oEqbcU=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.f17080086de35ea2d8ae7bbe8fd7dfab7183b485730a9353be99f4f0986495e5.js" integrity="sha256-8XCACG3jXqLYrnu&#43;j9ffq3GDtIVzCpNTvpn08JhkleU=" crossorigin="anonymous"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <meta name="referrer" content="no-referrer-when-downgrade"><!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Yeqown</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>







  
<ul>
  
  <li>
    <a href="/categories"  target="_blank" rel="noopener">
        Categories
      </a>
  </li>
  
  <li>
    <a href="/tags"  target="_blank" rel="noopener">
        Tags
      </a>
  </li>
  
</ul>










  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/aboutme/" class="">About Me</a>
  

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Stack实现O(1)的Min和Max：从空间换时间到数学魔法的探究</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#背景">背景</a></li>
    <li><a href="#方案一辅助栈-auxiliary-stack">方案一：辅助栈 (Auxiliary Stack)</a>
      <ul>
        <li><a href="#算法描述">算法描述</a></li>
        <li><a href="#伪代码描述">伪代码描述</a></li>
        <li><a href="#场景推演">场景推演</a></li>
      </ul>
    </li>
    <li><a href="#方案二差值标记法-value-difference">方案二：差值标记法 (Value Difference)</a>
      <ul>
        <li><a href="#算法设计">算法设计</a></li>
        <li><a href="#伪代码描述-1">伪代码描述</a></li>
        <li><a href="#深度复盘">深度复盘</a></li>
        <li><a href="#优势分析">优势分析</a></li>
      </ul>
    </li>
    <li><a href="#举一反三最小值的实现">举一反三：最小值的实现</a></li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown book-post">
  <h2>
    Stack实现O(1)的Min和Max：从空间换时间到数学魔法的探究
  </h2>
  
  <div class="flex align-center text-small book-post-date">
    <img src="/svg/calendar.svg" class="book-icon " alt="" />
    <span>March 1, 2018</span>
  </div>



  
  <div class="text-small">
    
      <a href="/categories/Algorithm/">Algorithm</a>
  </div>
  

  
  <div class="text-small">
    
      <a href="/tags/Golang/">Golang</a>, 
      <a href="/tags/Algorithm/">Algorithm</a>
  </div>
  


  <div class="book-post-content"><blockquote>
<p>栈（Stack）作为一种基础的数据结构，其 Push 和 Pop 操作的 $O(1)$ 时间复杂度通过栈顶指针即可轻松保证。但如果在实际业务场景或算法挑战中，要求我们实现 O(1) 时间复杂度内的 <code>Min</code> 和 <code>Max</code> 操作，问题就变得有趣起来了。</p>
</blockquote>
<h2 id="背景">
  背景
  <a class="anchor" href="#%e8%83%8c%e6%99%af">#</a>
</h2>
<p>在常规的栈实现中，如果我们需要获取栈内的最大值或最小值，通常的做法是遍历整个栈。这种做法的时间复杂度是 $O(N)$，其中 $N$ 是栈中元素的数量。</p>
<p>然而，在某些对性能要求苛刻的场景（如实时流监控窗口的最值计算）或者算法面试中，通常会要求我们将 <code>Min</code> 和 <code>Max</code> 的获取时间也压缩到 $O(1)$。</p>
<p>面对这个需求，我们最先想到的思路通常是“空间换时间”：即通过维护额外的状态来实时记录最值。那么，具体该如何设计并保证数据的一致性呢？</p>
<h2 id="方案一辅助栈-auxiliary-stack">
  方案一：辅助栈 (Auxiliary Stack)
  <a class="anchor" href="#%e6%96%b9%e6%a1%88%e4%b8%80%e8%be%85%e5%8a%a9%e6%a0%88-auxiliary-stack">#</a>
</h2>
<p>最直观的思路是设置一个辅助结构来同步记录最值。我们以“最大值”为例，引入一个辅助栈 <code>SMax</code>。</p>
<h3 id="算法描述">
  算法描述
  <a class="anchor" href="#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>State:
</span></span><span style="display:flex;"><span>  DataStack: [Integer] // The primary storage
</span></span><span style="display:flex;"><span>  SMax:      [Integer] // Auxiliary stack to store the sequence of maximums
</span></span></code></pre></div><p>在这个方案中，逻辑如下：</p>
<ul>
<li><strong>Push</strong>: 当元素入栈时，我们不仅将其压入数据栈；同时，比较该元素与 <code>SMax</code> 栈顶元素。如果该元素大于等于 <code>SMax</code> 栈顶元素（或者 <code>SMax</code> 为空），则将该元素也压入 <code>SMax</code>。</li>
<li><strong>Pop</strong>: 当元素出栈时，判断该元素是否等于 <code>SMax</code> 的栈顶元素。如果相等，说明我们要弹出的正是当前的最大值，因此 <code>SMax</code> 也要同步弹出栈顶。</li>
</ul>
<h3 id="伪代码描述">
  伪代码描述
  <a class="anchor" href="#%e4%bc%aa%e4%bb%a3%e7%a0%81%e6%8f%8f%e8%bf%b0">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Function Push(element):
</span></span><span style="display:flex;"><span>    DataStack.Push(element)
</span></span><span style="display:flex;"><span>    // If element is new max, push to SMax
</span></span><span style="display:flex;"><span>    IF SMax.IsEmpty() OR element &gt;= SMax.Top():
</span></span><span style="display:flex;"><span>        SMax.Push(element)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Function Pop():
</span></span><span style="display:flex;"><span>    value = DataStack.Pop()
</span></span><span style="display:flex;"><span>    // If we are popping the current max, pop from SMax too
</span></span><span style="display:flex;"><span>    IF value == SMax.Top():
</span></span><span style="display:flex;"><span>        SMax.Pop()
</span></span><span style="display:flex;"><span>    RETURN value
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Function GetMax():
</span></span><span style="display:flex;"><span>    RETURN SMax.Top()
</span></span></code></pre></div><h3 id="场景推演">
  场景推演
  <a class="anchor" href="#%e5%9c%ba%e6%99%af%e6%8e%a8%e6%bc%94">#</a>
</h3>
<p>为了验证这个逻辑，我们以序列 <code>1, 3, 6, 1, 12, 512, 12, 5121, 121, 412</code> 为例进行推演：</p>
<p><strong>Step-1. 元素 <code>1</code> 入栈</strong>
当前 <code>SMax</code> 为空，直接入栈。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Stack: 1
</span></span><span style="display:flex;"><span>SMax:  1
</span></span></code></pre></div><p><strong>Step-2. 元素 <code>3</code> 入栈</strong>
<code>3 &gt; 1</code>，为了保证 <code>SMax</code> 栈顶始终是当前最大值，<code>3</code> 入 <code>SMax</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Stack: 1, 3
</span></span><span style="display:flex;"><span>SMax:  1, 3
</span></span></code></pre></div><p><strong>Step-3. 元素 <code>6</code> 入栈</strong>
<code>6 &gt; 3</code>，同步更新。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Stack: 1, 3, 6
</span></span><span style="display:flex;"><span>SMax:  1, 3, 6
</span></span></code></pre></div><p>&hellip; 省略中间步骤 &hellip;</p>
<p><strong>Step-End. 所有元素入栈后</strong>
最终状态如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Stack: 1, 3, 6, 1, 12, 512, 12, 5121, 121, 412
</span></span><span style="display:flex;"><span>SMax:  1, 3, 6, 12, 512, 5121
</span></span></code></pre></div><blockquote>
<p>注：SMax 中仅存储比栈顶更大的新元素，因此 1, 12, 121, 412</p>
</blockquote>
<p>可以看到，这种方式逻辑清晰，实现简单。但从推演中我们也发现了一个明显的缺陷：<strong>空间复杂度</strong>。</p>
<p>如果入栈的元素是递增序列（如 <code>1, 2, 3, ... N</code>），那么 <code>SMax</code> 栈的大小将等同于数据栈，空间耗费为 $2N$。仅仅为了记录一个最值，耗费了一倍的额外空间，这显然不是最优解。</p>
<h2 id="方案二差值标记法-value-difference">
  方案二：差值标记法 (Value Difference)
  <a class="anchor" href="#%e6%96%b9%e6%a1%88%e4%ba%8c%e5%b7%ae%e5%80%bc%e6%a0%87%e8%ae%b0%e6%b3%95-value-difference">#</a>
</h2>
<p>有没有一种方法，既能保证 $O(1)$ 的时间复杂度，又能显著减少空间占用？</p>
<p>回顾我们的需求，我们真正关心的是“当前的最大值”。如果我们利用栈中存储的元素本身来承载一些“额外信息”，是否可行？答案是肯定的，我们可以存储<strong>差值</strong>。</p>
<h3 id="算法设计">
  算法设计
  <a class="anchor" href="#%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1">#</a>
</h3>
<p>在这个优化方案中，我们不再存储原始数值，而是存储 <strong>(当前元素 - 当前最大值)</strong> 的差值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>State:
</span></span><span style="display:flex;"><span>  DataStack: [Integer] // Stores the difference (Val - Max)
</span></span><span style="display:flex;"><span>  Max:       Integer   // Tracks the current maximum value
</span></span></code></pre></div><p>其核心逻辑显得略微“反直觉”，这里需要细细品味：</p>
<ul>
<li><strong>Push</strong>:
<ul>
<li>计算 <code>diff = 当前元素 - Max</code>，将 <code>diff</code> 入栈。</li>
<li>如果 <code>当前元素 &gt; Max</code>，说明最大值变了，更新 <code>Max = 当前元素</code>。</li>
<li><em>(注意：此时栈顶存储的 diff 是正数，标记了新 Max 的产生)</em></li>
</ul>
</li>
<li><strong>Pop</strong>:
<ul>
<li>取出 <code>栈顶元素 (diff)</code>。</li>
<li>如果 <code>diff &gt; 0</code>：说明在这个元素入栈时更新过 Max。当前实际弹出的元素就是 <code>Max</code>，而上一个 Max 的值可以通过 <code>Max - diff</code> 还原。我们需要更新 <code>Max = Max - diff</code>。</li>
<li>如果 <code>diff &lt;= 0</code>：说明入栈时比 Max 小，没更新过 Max。当前实际弹出的元素是 <code>Max + diff</code>，无需更新 Max。</li>
</ul>
</li>
</ul>
<h3 id="伪代码描述-1">
  伪代码描述
  <a class="anchor" href="#%e4%bc%aa%e4%bb%a3%e7%a0%81%e6%8f%8f%e8%bf%b0-1">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Function Push(element):
</span></span><span style="display:flex;"><span>    IF DataStack.IsEmpty():
</span></span><span style="display:flex;"><span>        Max = element
</span></span><span style="display:flex;"><span>        DataStack.Push(0) // 0 means element == Max
</span></span><span style="display:flex;"><span>    ELSE:
</span></span><span style="display:flex;"><span>        diff = element - Max
</span></span><span style="display:flex;"><span>        DataStack.Push(diff)
</span></span><span style="display:flex;"><span>        // If diff &gt; 0, it means element &gt; current Max
</span></span><span style="display:flex;"><span>        IF diff &gt; 0:
</span></span><span style="display:flex;"><span>            Max = element
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Function Pop():
</span></span><span style="display:flex;"><span>    diff = DataStack.Pop()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    IF diff &gt; 0:
</span></span><span style="display:flex;"><span>        // This element updated the Max when pushed
</span></span><span style="display:flex;"><span>        // Current value is Max, we need to restore previous Max
</span></span><span style="display:flex;"><span>        value = Max
</span></span><span style="display:flex;"><span>        Max = Max - diff
</span></span><span style="display:flex;"><span>        RETURN value
</span></span><span style="display:flex;"><span>    ELSE:
</span></span><span style="display:flex;"><span>        // Max was not updated by this element
</span></span><span style="display:flex;"><span>        // Original value was (Max + diff)
</span></span><span style="display:flex;"><span>        RETURN Max + diff
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Function GetMax():
</span></span><span style="display:flex;"><span>    RETURN Max
</span></span></code></pre></div><h3 id="深度复盘">
  深度复盘
  <a class="anchor" href="#%e6%b7%b1%e5%ba%a6%e5%a4%8d%e7%9b%98">#</a>
</h3>
<p>这个逻辑比较抽象，我们用一组数据 <code>5, 23, 12, 499, 45, 20, 60</code> 来进行一次完整的“抓包”分析。</p>
<p><strong>Step-1. 元素 <code>5</code> 入栈</strong>
当前 <code>Max</code> 初始化为极小值。
入栈内容：<code>5 - MinInt</code> (正数)。
更新 <code>Max = 5</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Stack: [5-MinInt]
</span></span><span style="display:flex;"><span>Max:   5
</span></span></code></pre></div><p><strong>Step-2. 元素 <code>23</code> 入栈</strong>
当前元素 <code>23 &gt; Max(5)</code>。
入栈内容：<code>23 - 5 = 18</code>。
更新 <code>Max = 23</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Stack: [..., 18]
</span></span><span style="display:flex;"><span>Max:   23
</span></span></code></pre></div><p><strong>Step-3. 元素 <code>12</code> 入栈</strong>
当前元素 <code>12 &lt; Max(23)</code>。
入栈内容：<code>12 - 23 = -11</code>。
不更新 Max。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Stack: [..., 18, -11]
</span></span><span style="display:flex;"><span>Max:   23
</span></span></code></pre></div><p>此时，如果我们要进行 Pop 操作，流程如下：</p>
<p><strong>Step-4. 弹出栈顶 <code>-11</code></strong>
栈顶 <code>-11 &lt; 0</code>。
这意味着当前 Max 并不是在这个元素入栈时被修改的。
还原真实元素：<code>Max(23) + (-11) = 12</code>。
Max 保持 <code>23</code> 不变。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Stack: [..., 18]
</span></span><span style="display:flex;"><span>Max:   23
</span></span></code></pre></div><p><em>结果正确：弹出了 12，且 Max 仍为 23。</em></p>
<p><strong>Step-5. 弹出栈顶 <code>18</code></strong>
栈顶 <code>18 &gt; 0</code>。
这是一个关键信号！说明当初这个元素入栈时，它推高了 Max 值。
当前真实元素就是 <code>Max(23)</code>。
我们需要“回溯” Max 值：<code>NewMax = Max(23) - 18 = 5</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Stack: [...]
</span></span><span style="display:flex;"><span>Max:   5
</span></span></code></pre></div><p><em>结果正确：弹出了 23，且 Max 恢复为了 5。</em></p>
<h3 id="优势分析">
  优势分析
  <a class="anchor" href="#%e4%bc%98%e5%8a%bf%e5%88%86%e6%9e%90">#</a>
</h3>
<p>相较于辅助栈方案，差值法的优势在于：</p>
<ol>
<li><strong>空间效率</strong>：不需要额外的 $O(N)$ 空间存储辅助栈，仅需 $O(1)$ 的变量存储 Max。</li>
<li><strong>优雅性</strong>：利用数学特性（加减逆运算）还原上下文，减少了数据结构的复杂度。</li>
</ol>
<h2 id="举一反三最小值的实现">
  举一反三：最小值的实现
  <a class="anchor" href="#%e4%b8%be%e4%b8%80%e5%8f%8d%e4%b8%89%e6%9c%80%e5%b0%8f%e5%80%bc%e7%9a%84%e5%ae%9e%e7%8e%b0">#</a>
</h2>
<p>上述逻辑着重探究了 Max 的实现，对于 Min 的实现，原理是完全对称的。</p>
<p>对于<strong>辅助栈法</strong>，我们只需要维护一个 <code>SMin</code> 栈，Push 时若当前元素 <code>&lt;= SMin</code> 栈顶则入栈，Pop 时若等于则出栈。</p>
<p>对于<strong>差值标记法</strong>，逻辑稍作调整：</p>
<ul>
<li><strong>Push</strong>: 存储 <code>当前元素 - Min</code>。若 <code>当前元素 &lt; Min</code>，则更新 <code>Min</code>。此时入栈的差值为负数。</li>
<li><strong>Pop</strong>: 若 <code>栈顶元素 &lt; 0</code>，说明更新过 Min，还原 <code>PreMin = Min - 栈顶元素</code>。</li>
</ul>
<h2 id="总结">
  总结
  <a class="anchor" href="#%e6%80%bb%e7%bb%93">#</a>
</h2>
<p>本文从一个简单的 $O(1)$ 最值需求出发，展示了两种截然不同的解决思路。</p>
<ul>
<li><strong>辅助栈法</strong>胜在直观、易理解，符合线性思维，但在极端情况下空间浪费严重。</li>
<li><strong>差值标记法</strong>利用了数据的相对关系，通过数学变换将“历史状态”编码在当前数据中，实现了极致的空间优化。</li>
</ul>
<p>在实际工程和算法设计中，这种“利用数据间的相对关系来压缩信息”的思想（类似差分数组、前缀和）是非常通用的解题利器。知其然更知其所以然，才能在面对更复杂的问题时游刃有余。</p>
</div>
</article>


<section class="comment">
  <div id="gitalk-container"></div>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  <script>
      const gitalk = new Gitalk({
          clientID: '7d8c8c91ae6aff3e46e7',
          clientSecret: '0f0f2ea4fb6eb3067955823f06286e7d88509b9f',
          repo: 'yeqown.github.io',
          owner: 'yeqown',
          admin: ['yeqown'],
          id: "stack-implement-o1-min-max", 
          distractionFreeMode: false 
      });
      (function () {
          if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
              document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
              return;
          }
          gitalk.render('gitalk-container');
      })();
  </script>
</section>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">






<div class="flex align-center">
    <span id="busuanzi_container_site_pv" style="margin-right: 10px;">
        访问量<span id="busuanzi_value_site_pv"></span>
    </span>
    <span id="busuanzi_container_site_uv" style="margin-right: 10px;">
        访客数<span id="busuanzi_value_site_uv"></span>
    </span>
</div></div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#背景">背景</a></li>
    <li><a href="#方案一辅助栈-auxiliary-stack">方案一：辅助栈 (Auxiliary Stack)</a>
      <ul>
        <li><a href="#算法描述">算法描述</a></li>
        <li><a href="#伪代码描述">伪代码描述</a></li>
        <li><a href="#场景推演">场景推演</a></li>
      </ul>
    </li>
    <li><a href="#方案二差值标记法-value-difference">方案二：差值标记法 (Value Difference)</a>
      <ul>
        <li><a href="#算法设计">算法设计</a></li>
        <li><a href="#伪代码描述-1">伪代码描述</a></li>
        <li><a href="#深度复盘">深度复盘</a></li>
        <li><a href="#优势分析">优势分析</a></li>
      </ul>
    </li>
    <li><a href="#举一反三最小值的实现">举一反三：最小值的实现</a></li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












