<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="“熟悉http协议”，肯定很多IT小伙伴都在招聘岗位上看得到过，但是怎么才叫熟悉http协议呢？抽空梳理了一下，也算是对这一部分知识的笔记吧！">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://www.yeqown.xyz/2018/06/28/%E6%80%8E%E4%B9%88%E6%89%8D%E5%8F%AB%E7%86%9F%E6%82%89http%E5%8D%8F%E8%AE%AE/">
  <meta property="og:site_name" content="Yeqown">
  <meta property="og:title" content="怎么才叫熟悉http协议?">
  <meta property="og:description" content="“熟悉http协议”，肯定很多IT小伙伴都在招聘岗位上看得到过，但是怎么才叫熟悉http协议呢？抽空梳理了一下，也算是对这一部分知识的笔记吧！">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2018-06-28T14:50:08+00:00">
    <meta property="article:modified_time" content="2018-06-28T14:50:08+00:00">
    <meta property="article:tag" content="HTTP">
    <meta property="article:tag" content="Note">
<title>怎么才叫熟悉http协议? | Yeqown</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="https://www.yeqown.xyz/2018/06/28/%E6%80%8E%E4%B9%88%E6%89%8D%E5%8F%AB%E7%86%9F%E6%82%89http%E5%8D%8F%E8%AE%AE/">
<link rel="stylesheet" href="/book.min.c2fbf3db843e2f212ac724c116ea0973ae0c44d9926b1c14e16b29de812a6dc5.css" integrity="sha256-wvvz24Q&#43;LyEqxyTBFuoJc64MRNmSaxwU4Wsp3oEqbcU=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.f17080086de35ea2d8ae7bbe8fd7dfab7183b485730a9353be99f4f0986495e5.js" integrity="sha256-8XCACG3jXqLYrnu&#43;j9ffq3GDtIVzCpNTvpn08JhkleU=" crossorigin="anonymous"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <meta name="referrer" content="no-referrer-when-downgrade"><!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Yeqown</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>







  
<ul>
  
  <li>
    <a href="/categories"  target="_blank" rel="noopener">
        Categories
      </a>
  </li>
  
  <li>
    <a href="/tags"  target="_blank" rel="noopener">
        Tags
      </a>
  </li>
  
</ul>










  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/aboutme/" class="">About Me</a>
  

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>怎么才叫熟悉http协议?</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#基础知识">基础知识</a></li>
        <li><a href="#http报文">HTTP报文</a></li>
        <li><a href="#http头部">HTTP头部</a></li>
        <li><a href="#http-methods">HTTP Methods</a></li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#参考资料">参考资料</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown book-post">
  <h2>
    怎么才叫熟悉http协议?
  </h2>
  
  <div class="flex align-center text-small book-post-date">
    <img src="/svg/calendar.svg" class="book-icon " alt="" />
    <span>June 28, 2018</span>
  </div>



  
  <div class="text-small">
    
      <a href="/categories/%E6%80%BB%E7%BB%93/">总结</a>
  </div>
  

  
  <div class="text-small">
    
      <a href="/tags/HTTP/">HTTP</a>, 
      <a href="/tags/Note/">Note</a>
  </div>
  


  <div class="book-post-content"><p>“熟悉http协议”，肯定很多IT小伙伴都在招聘岗位上看得到过，但是怎么才叫熟悉http协议呢？抽空梳理了一下，也算是对这一部分知识的笔记吧！</p>
<p>可能对于大部分人来说，网络web编程就是使用一些第三方库来进行请求和响应的处理，再多说一点就是这个<code>URI</code>要使用<code>POST</code>方法，对于携带的数据需要处理成为<code>formdata</code>。</p>
<!-- more -->
<h3 id="基础知识">
  基础知识
  <a class="anchor" href="#%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86">#</a>
</h3>
<p><strong>Q1: HTTP协议是什么？用来干什么？</strong></p>
<blockquote>
<p>HTTP协议是基于TCP/IP协议的应用层协议，主要规定了客户端和服务端之间的通信格式。主要作用也就是传输数据（HTML，图片，文件，查询结果）。</p>
</blockquote>
<h4 id="网络分层">
  #网络分层
  <a class="anchor" href="#%e7%bd%91%e7%bb%9c%e5%88%86%e5%b1%82">#</a>
</h4>
<blockquote>
<p>互联网的实现分成了几层，如何分层有不同的模型（七层，五层，四层），这里按五层模型来解释：</p>
</blockquote>
<p>（靠近用户）应用层 &lt; 传输层 &lt; 网络层 &lt; 链接层 &lt; 物理层（靠近硬件）</p>
<table>
  <thead>
      <tr>
          <th>层级</th>
          <th>作用</th>
          <th>拥有协议</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>物理层</td>
          <td>传送电信号0 1</td>
          <td>无</td>
      </tr>
      <tr>
          <td>数据链路层</td>
          <td>定义数据包;网卡MAC地址;广播的发送方式;</td>
          <td>Ethernet 802.3; Token Ring 802.5</td>
      </tr>
      <tr>
          <td>网络层</td>
          <td>引进了IP地址，用于区分不同的计算机是否属于同一网络</td>
          <td>IP; ARP; RARP</td>
      </tr>
      <tr>
          <td>传输层</td>
          <td>建立端口到端口的通信，实现程序时间的交流，也就是socket</td>
          <td>TCP; UDP</td>
      </tr>
      <tr>
          <td>应用层</td>
          <td>约定应用程序的数据格式</td>
          <td>HTTP; FTP; DNS</td>
      </tr>
  </tbody>
</table>
<p><em>每一层级，都是解决问题而诞生的，也就是他们各自作用对应的问题，推荐参考资料中的“互联网协议入门”。</em></p>
<h4 id="http通信流程">
  #HTTP通信流程
  <a class="anchor" href="#http%e9%80%9a%e4%bf%a1%e6%b5%81%e7%a8%8b">#</a>
</h4>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/2/1628583763cf81ca?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="http通信传输流" /></p>
<h4 id="拓展--三次握手和四次挥手">
  #拓展&ndash;三次握手和四次挥手
  <a class="anchor" href="#%e6%8b%93%e5%b1%95--%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%92%8c%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b">#</a>
</h4>
<p>经常在其他地方看到这些，一直不知道了解这部分有什么用，但是<a href="https://en.wikipedia.org/wiki/SYN_flood"><code>syn Flood</code></a>攻击，恰恰是利用了TCP三次握手中的环节。利用假IP伪造<code>SYN</code>请求，服务端会多次尝试发送<code>SYN-ACK</code>给客户端，但是IP并不存在也就无法成功建立连接。在一定时间内伪造大量这种请求，会导致服务器资源耗尽无法为正常的连接服务。(注：服务器SYN连接数量有限制，SYN-ACK超时重传机制)</p>
<p>三次握手流程：</p>
<blockquote>
<ol>
<li>The client requests a connection by sending a SYN (synchronize) message to the server.</li>
<li>The server acknowledges this request by sending SYN-ACK back to the client.</li>
<li>The client responds with an ACK, and the connection is established.</li>
</ol>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Tcp_normal.svg/220px-Tcp_normal.svg.png" alt="TCP three-way handshake" /></p>
<p>四次挥手流程：</p>
<blockquote>
<p>When an endpoint wishes to stop its half of the connection, it transmits a FIN packet. which the other end acknowledges with an ACK. Therefore, a typical tear-down requires a pair of FIN and ACK segments from each TCP endpoint. After the side that sent the first FIN has responded with the final ACK, it waits for a timeout before finally closing the connection, during which time the local port is unavailable for new connections.</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2d/Deconnection_TCP.png/220px-Deconnection_TCP.png" alt="TCP close connection" /></p>
<h3 id="http报文">
  HTTP报文
  <a class="anchor" href="#http%e6%8a%a5%e6%96%87">#</a>
</h3>
<blockquote>
<p>HTTP报文是由一行一行的简单字符串组成的，HTTP报文都是纯文本。</p>
</blockquote>
<p>HTTP报文包括三个部分：起始行；头部字段；主体数据。其中头部是非常重要的部分，会单独成章。</p>
<p><img src="/images/http_request_content.png" alt="Request" />
举例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>GET / HTTP/1.1
</span></span><span style="display:flex;"><span>Host: www.baidu.com
</span></span><span style="display:flex;"><span>Connection: keep-alive
</span></span><span style="display:flex;"><span>Upgrade-Insecure-Requests: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>User-Agent: Mozilla/5.0 <span style="color:#f92672">(</span>Macintosh; Intel Mac OS X 10_11_6<span style="color:#f92672">)</span> AppleWebKit/537.36 <span style="color:#f92672">(</span>KHTML, like Gecko<span style="color:#f92672">)</span> Chrome/54.0.2840.71 Safari/537.36
</span></span><span style="display:flex;"><span>Accept: text/html,application/xhtml+xml,application/xml;q<span style="color:#f92672">=</span>0.9,image/webp,*/*;q<span style="color:#f92672">=</span>0.8
</span></span><span style="display:flex;"><span>Accept-Encoding: gzip, deflate, sdch
</span></span><span style="display:flex;"><span>Accept-Language: zh-CN,zh;q<span style="color:#f92672">=</span>0.8,en;q<span style="color:#f92672">=</span>0.6
</span></span><span style="display:flex;"><span>Cookie: BAIDUID<span style="color:#f92672">=</span>4082549DEE5E64678FC46642E185D98C:FG<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p><img src="/images/http_response_content.png" alt="Response" />
举例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>HTTP/1.1 <span style="color:#ae81ff">200</span> OK
</span></span><span style="display:flex;"><span>Server: bfe/1.0.8.18
</span></span><span style="display:flex;"><span>Date: Thu, <span style="color:#ae81ff">03</span> Nov <span style="color:#ae81ff">2016</span> 08:30:43 GMT
</span></span><span style="display:flex;"><span>Content-Type: text/html
</span></span><span style="display:flex;"><span>Content-Length: <span style="color:#ae81ff">277</span>
</span></span><span style="display:flex;"><span>Last-Modified: Mon, <span style="color:#ae81ff">13</span> Jun <span style="color:#ae81ff">2016</span> 02:50:03 GMT
</span></span><span style="display:flex;"><span>Connection: Keep-Alive
</span></span><span style="display:flex;"><span>ETag: <span style="color:#e6db74">&#34;575e1f5b-115&#34;</span>
</span></span><span style="display:flex;"><span>Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
</span></span><span style="display:flex;"><span>Pragma: no-cache
</span></span><span style="display:flex;"><span>Accept-Ranges: bytes
</span></span></code></pre></div><h4 id="状态码">
  #状态码
  <a class="anchor" href="#%e7%8a%b6%e6%80%81%e7%a0%81">#</a>
</h4>
<p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>
<p>1xx：指示信息 （表示请求已接收，继续处理）
2xx：成功 （表示请求已被成功接收、理解、接受）
3xx：重定向 （要完成请求必须进行更进一步的操作）
4xx：客户端错误 （请求有语法错误或请求无法实现）
5xx：服务器端错误 （服务器未能实现合法的请求）</p>
<p>这里我觉得很有必要说一下的：3xx。最近开发的时候遇到一个情况：</p>
<p>从页面上post跳转到第三方页面，完成后对方会通过POST携带数据的方式返回到我们的页面。在前后端分离的开发模式下，暂时没有想到前端自行解决的方法，因此我们通过服务端来处理这个POST回调接受数据，再通过重定向的方式，跳回到我们自己的页面（只需要将处理结果：成功或者失败，通过url参数传给前端）。</p>
<p>重定向的时候，随便选择了一个307（Temporary Redirect），然后返回页面的时候还是会提示：“501 Not Implemented， 意思就是：页面不支持POST请求”。解决办法是要把这个POST转成GET咯，怎么转呢？如下：</p>
<table>
  <thead>
      <tr>
          <th>Code</th>
          <th>Text</th>
          <th>Method handling</th>
          <th>Typical use case</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>302</td>
          <td>Found</td>
          <td>GET methods unchanged.Others may or may not be changed to GET</td>
          <td>The Web page is temporarily not available for reasons that have not been unforeseen. That way, search engines don&rsquo;t update their links.</td>
      </tr>
      <tr>
          <td>303</td>
          <td>See Other</td>
          <td>GET methods unchanged.Others changed to GET (body lost).</td>
          <td>Used to redirect after a PUT or a POST to prevent a refresh of the page that would re-trigger the operation.</td>
      </tr>
      <tr>
          <td>307</td>
          <td>Temporary</td>
          <td>Redirect Method and body not changed.</td>
          <td>The Web page is temporarily not available for reasons that have not been unforeseen. That way, search engines don&rsquo;t update their links. Better than 302 when non-GET links/operations are available on the site.</td>
      </tr>
  </tbody>
</table>
<p>我们需要的就是303了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Redirect</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">url</span>, <span style="color:#ae81ff">303</span>) <span style="color:#75715e">// 把r(POST)重定向到url(GET)
</span></span></span></code></pre></div><h3 id="http头部">
  HTTP头部
  <a class="anchor" href="#http%e5%a4%b4%e9%83%a8">#</a>
</h3>
<p>这部分也就是常说的Header，在HTTP协议中头部主要作用为：传递额外信息。在HTTP中头部常见分类有：请求头部/响应头部/通用头部/实体头部。
这里也不细说每个请求头的作用了（反正都是搜集别人的资料～，可以参见<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">MDN HTTP Headers</a>），就放几个可能会有帮助的：</p>
<h4 id="set-cookie-response">
  #Set-Cookie [Response]
  <a class="anchor" href="#set-cookie-response">#</a>
</h4>
<p>发送cookies到客户端，客户端请求的时候带上Cookie发送给服务端，可以完成一些验证。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt; 
</span></span><span style="display:flex;"><span>Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; Expires<span style="color:#f92672">=</span>&lt;date&gt;
</span></span><span style="display:flex;"><span>Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; Max-Age<span style="color:#f92672">=</span>&lt;non-zero-digit&gt;
</span></span><span style="display:flex;"><span>Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; Domain<span style="color:#f92672">=</span>&lt;domain-value&gt;
</span></span><span style="display:flex;"><span>Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; Path<span style="color:#f92672">=</span>&lt;path-value&gt;
</span></span><span style="display:flex;"><span>Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; Secure
</span></span><span style="display:flex;"><span>Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; HttpOnly
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; SameSite<span style="color:#f92672">=</span>Strict
</span></span><span style="display:flex;"><span>Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; SameSite<span style="color:#f92672">=</span>Lax
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// Multiple directives are also possible, <span style="color:#66d9ef">for</span> example:
</span></span><span style="display:flex;"><span>Set-Cookie: &lt;cookie-name&gt;<span style="color:#f92672">=</span>&lt;cookie-value&gt;; Domain<span style="color:#f92672">=</span>&lt;domain-value&gt;; Secure; HttpOnly
</span></span></code></pre></div><h4 id="access-control-allow-origin-repsonse">
  #Access-Control-Allow-Origin [Repsonse]
  <a class="anchor" href="#access-control-allow-origin-repsonse">#</a>
</h4>
<p>允许哪个域可以访问你的资源</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>Access-Control-Allow-Origin: *
</span></span><span style="display:flex;"><span>Access-Control-Allow-Origin: &lt;origin&gt;
</span></span></code></pre></div><h4 id="access-control-allow-credentials-response">
  #Access-Control-Allow-Credentials [Response]
  <a class="anchor" href="#access-control-allow-credentials-response">#</a>
</h4>
<p>跨域请求必设置</p>
<blockquote>
<p>The Access-Control-Allow-Credentials header works in conjunction with the <strong><code>XMLHttpRequest.withCredentials</code></strong> property or with the <strong><code>credentials</code></strong> option in the Request() constructor of the <strong><code>Fetch API</code></strong>. Credentials must be set on both sides (the Access-Control-Allow-Credentials header and in the XHR or Fetch request) in order for the CORS request with credentials to succeed.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>Access-Control-Allow-Credentials: true
</span></span></code></pre></div><h4 id="access-control-allow-methods-response">
  #Access-Control-Allow-Methods [Response]
  <a class="anchor" href="#access-control-allow-methods-response">#</a>
</h4>
<p>响应头指定访问资源以响应预检请求时允许的方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>Access-Control-Allow-Methods: &lt;method&gt;, &lt;method&gt;, ...
</span></span></code></pre></div><h4 id="access-control-allow-headers-response">
  #Access-Control-Allow-Headers [Response]
  <a class="anchor" href="#access-control-allow-headers-response">#</a>
</h4>
<p>（预检请求）用于指明在实际请求中可以使用哪些HTTP头。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>Access-Control-Allow-Headers: &lt;header-name&gt;, &lt;header-name&gt;, ...
</span></span></code></pre></div><h4 id="content-type-responserequest">
  #Content-Type [Response/Request]
  <a class="anchor" href="#content-type-responserequest">#</a>
</h4>
<p>用于表明资源是哪种格式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>Content-Type: text/html; charset<span style="color:#f92672">=</span>utf-8
</span></span><span style="display:flex;"><span>Content-Type: multipart/form-data; boundary<span style="color:#f92672">=</span>something
</span></span></code></pre></div><h3 id="http-methods">
  HTTP Methods
  <a class="anchor" href="#http-methods">#</a>
</h3>
<table>
  <thead>
      <tr>
          <th>方法</th>
          <th>描述</th>
          <th>使用场景</th>
          <th>请求是否有body</th>
          <th>响应是否有body</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>GET</td>
          <td>获取指定资源</td>
          <td>获取网页，查询资源</td>
          <td>没有</td>
          <td>有</td>
      </tr>
      <tr>
          <td>POST</td>
          <td>发送数据给服务端</td>
          <td>新建资源；用户通过表单登录</td>
          <td>有</td>
          <td>有</td>
      </tr>
      <tr>
          <td>PUT</td>
          <td>新建资源或者替换指定资源</td>
          <td>更新一条记录</td>
          <td>有</td>
          <td>有</td>
      </tr>
      <tr>
          <td>DELETE</td>
          <td>删除指定资源</td>
          <td>删除一条记录；</td>
          <td>有</td>
          <td>有</td>
      </tr>
      <tr>
          <td>OPTIONS</td>
          <td>用于描述特定资源的访问选项</td>
          <td>获取服务端支持的请求方法</td>
          <td>没有</td>
          <td>有</td>
      </tr>
      <tr>
          <td>CONNECT</td>
          <td>开启双向通信</td>
          <td>undefined</td>
          <td>没有</td>
          <td>有</td>
      </tr>
      <tr>
          <td>HEAD</td>
          <td>描述</td>
          <td>使用场景</td>
          <td>没有</td>
          <td>没有</td>
      </tr>
      <tr>
          <td>PATCH</td>
          <td>对资源部分更改</td>
          <td>使用场景</td>
          <td>有</td>
          <td>没有</td>
      </tr>
      <tr>
          <td>TRACE</td>
          <td>描述</td>
          <td>使用场景</td>
          <td>有</td>
          <td>有</td>
      </tr>
  </tbody>
</table>
<h4 id="get和post区别">
  #GET和POST区别
  <a class="anchor" href="#get%e5%92%8cpost%e5%8c%ba%e5%88%ab">#</a>
</h4>
<p>被人熟知的区别有以下几点：</p>
<blockquote>
<ul>
<li>GET后退按钮/刷新无害，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</li>
<li>GET能被缓存，POST大部分不缓存。</li>
<li>GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</li>
<li>GET对数据长度有限制，当发送数据时，GET方法向URL添加数据；URL 的长度是受限制的（URL的最大长度是2048个字符。POST无限制。</li>
<li>GET只允许ASCII字符。POST没有限制。也允许二进制数据。</li>
<li>与 POST 相比，GET的安全性较差，因为所发送的数据是URL的一部分。</li>
</ul>
</blockquote>
<p>上述是从表象来说两者有什么区别，那么从方法语义呢？<a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/">HTTP协议中GET和POST的区别</a>好吧，其实就是说：GET请求对于资源不应该产生影响，POST	请求会造成资源变化，且多次请求变化不固定（非幂等）。</p>
<h4 id="put和post区别">
  #PUT和POST区别
  <a class="anchor" href="#put%e5%92%8cpost%e5%8c%ba%e5%88%ab">#</a>
</h4>
<p>同一个PUT调用多次，不对产生其他影响，返回结果一致，资源变化一致。但是多次提交相同的POST可能会有不一样的响应，根据设计的不同，服务端可能提示：资源重复，或者新增相同的资源多次。也就是说PUT幂等，POST非幂等。</p>
<h3 id="总结">
  总结
  <a class="anchor" href="#%e6%80%bb%e7%bb%93">#</a>
</h3>
<p>上述只能算HTTP协议的小部分知识，其包含及相关知识还有很多，如基本的HTTP鉴权，HTTPS的工作流程，HTTP如何基于TCP/IP协议来实现的。</p>
<h3 id="参考资料">
  参考资料
  <a class="anchor" href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99">#</a>
</h3>
<ul>
<li><a href="https://juejin.im/post/5ac1eb2d6fb9a028de44dd41">来一场轰轰烈烈的HTTP协议扫盲</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">HTTP协议入门</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">互联网协议入门</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">MDN HTTP Headers</a></li>
<li><a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/">HTTP协议中GET和POST的区别</a></li>
</ul>
</div>
</article>


<section class="comment">
  <div id="gitalk-container"></div>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  <script>
      const gitalk = new Gitalk({
          clientID: '7d8c8c91ae6aff3e46e7',
          clientSecret: '0f0f2ea4fb6eb3067955823f06286e7d88509b9f',
          repo: 'yeqown.github.io',
          owner: 'yeqown',
          admin: ['yeqown'],
          id: "how-to-know-http-protocol", 
          distractionFreeMode: false 
      });
      (function () {
          if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
              document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
              return;
          }
          gitalk.render('gitalk-container');
      })();
  </script>
</section>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">






<div class="flex align-center">
    <span id="busuanzi_container_site_pv" style="margin-right: 10px;">
        访问量<span id="busuanzi_value_site_pv"></span>
    </span>
    <span id="busuanzi_container_site_uv" style="margin-right: 10px;">
        访客数<span id="busuanzi_value_site_uv"></span>
    </span>
</div></div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#基础知识">基础知识</a></li>
        <li><a href="#http报文">HTTP报文</a></li>
        <li><a href="#http头部">HTTP头部</a></li>
        <li><a href="#http-methods">HTTP Methods</a></li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#参考资料">参考资料</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












