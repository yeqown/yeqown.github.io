<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Yeqown</title>
    <link>https://www.yeqown.xyz/categories/Algorithm/</link>
    <description>Recent content in Algorithm on Yeqown</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Fri, 05 Apr 2019 14:51:46 +0000</lastBuildDate>
    <atom:link href="https://www.yeqown.xyz/categories/Algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>介绍一下snowflake和rc4</title>
      <link>https://www.yeqown.xyz/2019/04/05/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bsnowflake%E5%92%8Crc4/</link>
      <pubDate>Fri, 05 Apr 2019 14:51:46 +0000</pubDate>
      <guid>https://www.yeqown.xyz/2019/04/05/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bsnowflake%E5%92%8Crc4/</guid>
      <description>&lt;p&gt;&lt;code&gt;snowflake&lt;/code&gt;是twitter公司开源的生成唯一ID的网络服务，具有很强的伸缩性，这里只取用生成唯一ID的算法部分。&#xA;&lt;code&gt;rc4&lt;/code&gt;（Rivest Cipher 4）是一种流加密算法，密钥长度可变，它的加解密使用相同的密钥，因此也属于对称加密算法。&lt;/p&gt;&#xA;&lt;!-- more --&gt;&#xA;&lt;h3 id=&#34;为啥要介绍这两种算法&#34;&gt;&#xA;  为啥要介绍这两种算法？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e5%95%a5%e8%a6%81%e4%bb%8b%e7%bb%8d%e8%bf%99%e4%b8%a4%e7%a7%8d%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;其一，&lt;code&gt;snowflake&lt;/code&gt;可以生成唯一ID，而相比与&lt;code&gt;UUID&lt;/code&gt;，&lt;code&gt;snowflake&lt;/code&gt;生成的ID更加“好用”，这个放在后面解释。&#xA;其二，&lt;code&gt;UUID&lt;/code&gt;和&lt;code&gt;snowflake&lt;/code&gt;虽然可以生成唯一ID，但是无法适用于所有场景，譬如说“生成推广码”。生成推广码的时候，希望尽可能短而精，很明显唯一ID都不太短。&lt;/p&gt;&#xA;&lt;h3 id=&#34;snowflake&#34;&gt;&#xA;  snowflake&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#snowflake&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;snowflake的唯一ID是一个64bit的int型数据，相较于UUID来说耗费空间更小，可以更方便的作为数据库主键来索引和排序。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.yeqown.xyz/images/snowflake.png&#34; alt=&#34;snowflake&#34; /&gt;&lt;/p&gt;&#xA;&lt;h6 id=&#34;生成过程&#34;&gt;&#xA;  生成过程：&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%9f%e6%88%90%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h6&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;置0不用&lt;/li&gt;&#xA;&lt;li&gt;timestamp（41bits）精确到ms。&lt;/li&gt;&#xA;&lt;li&gt;machine-id（10bits）该部分其实由datacenterId和workerId两部分组成，这两部分是在配置文件中指明的。datacenterId（5bits）方便搭建多个生成uid的service，并保证uid不重复。workerId（5bits）是实际server机器的代号，最大到32，同一个datacenter下的workerId是不能重复的。&lt;/li&gt;&#xA;&lt;li&gt;sequence-id(12bits)，该id可以表示4096个数字，它是在time相同的情况下，递增该值直到为0，即一个循环结束，此时便只能等到下一个ms到来，一般情况下4096/ms的请求是不太可能出现的，所以足够使用了。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h6 id=&#34;优势和缺陷&#34;&gt;&#xA;  优势和缺陷：&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%98%e5%8a%bf%e5%92%8c%e7%bc%ba%e9%99%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h6&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;速度快，无依赖，原理和实现简单，也可以根据自己的需求做算法调整&lt;/li&gt;&#xA;&lt;li&gt;依赖机器时间，如果时间回拨可能导致重复的ID&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;rc4&#34;&gt;&#xA;  rc4&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#rc4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;RC4加密算法也是一种基于密钥流的加密算法。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;首先，rc4根据明文和密钥生成的密钥流，其长度和明文的长度是相等的，也就是说明文的长度是500字节，那么密钥流也是500字节，这也是我们用来生成&lt;code&gt;推广码&lt;/code&gt;的原因之一了；其次，rc4是是对称加密完全可以通过密文得到明文，也就是说在生成码的时候把必要信息放在明文中，在使用密文的时候可以不用查库也能得到相关的信息，譬如用户ID，这是原因之二。&lt;/p&gt;&#xA;&lt;h6 id=&#34;使用场景&#34;&gt;&#xA;  使用场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h6&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;现在需要生成一种码，短小易记，且唯一，但并不需要大量。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;上述的snowflake和UUID都很容易实现唯一，但是短小就不符合要求了。因为并不需要大量生成这种码，因此我们考虑用&lt;code&gt;自增ID + RC4&lt;/code&gt;来实现：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;crypto/rc4&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;encoding/hex&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;log&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;cipher&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rc4&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;NewCipher&lt;/span&gt;([]byte(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;thisiskey&amp;#34;&lt;/span&gt;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;wrong with NewCipher: %v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;{}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []byte(&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Sprintf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%7d&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;dst&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;cipher&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;XORKeyStream&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;dst&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;dst&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 密文是不可读的字节流，这里采用hex编码&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#x9;&#x9;println(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;)         &lt;span style=&#34;color:#75715e&#34;&gt;// 形如：a09def6b6e4797&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;] = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;println(len(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;)) &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hex&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;EncodeToString&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;参考&#34;&gt;&#xA;  参考&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/twitter-archive/snowflake&#34;&gt;twitter-snowflake&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/bwmarrin/snowflake&#34;&gt;bwmarrin/snowflake&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/yeqown/snowflake&#34;&gt;yeqown/snowflake&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://juejin.im/entry/59b5ef585188257e8901487d&#34;&gt;关于snowflake的分析&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.kancloud.cn/db-design/mysql-dba/596722&#34;&gt;为什么推荐InnoDB引擎使用自增主键?&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Stack实现O(1)的Min和Max：从空间换时间到数学魔法的探究</title>
      <link>https://www.yeqown.xyz/2018/03/01/Stack%E5%AE%9E%E7%8E%B0O1%E7%9A%84Min%E5%92%8CMax/</link>
      <pubDate>Thu, 01 Mar 2018 16:26:05 +0800</pubDate>
      <guid>https://www.yeqown.xyz/2018/03/01/Stack%E5%AE%9E%E7%8E%B0O1%E7%9A%84Min%E5%92%8CMax/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;栈（Stack）作为一种基础的数据结构，其 Push 和 Pop 操作的 $O(1)$ 时间复杂度通过栈顶指针即可轻松保证。但如果在实际业务场景或算法挑战中，要求我们实现 O(1) 时间复杂度内的 &lt;code&gt;Min&lt;/code&gt; 和 &lt;code&gt;Max&lt;/code&gt; 操作，问题就变得有趣起来了。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;背景&#34;&gt;&#xA;  背景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%83%8c%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;在常规的栈实现中，如果我们需要获取栈内的最大值或最小值，通常的做法是遍历整个栈。这种做法的时间复杂度是 $O(N)$，其中 $N$ 是栈中元素的数量。&lt;/p&gt;&#xA;&lt;p&gt;然而，在某些对性能要求苛刻的场景（如实时流监控窗口的最值计算）或者算法面试中，通常会要求我们将 &lt;code&gt;Min&lt;/code&gt; 和 &lt;code&gt;Max&lt;/code&gt; 的获取时间也压缩到 $O(1)$。&lt;/p&gt;&#xA;&lt;p&gt;面对这个需求，我们最先想到的思路通常是“空间换时间”：即通过维护额外的状态来实时记录最值。那么，具体该如何设计并保证数据的一致性呢？&lt;/p&gt;&#xA;&lt;h2 id=&#34;方案一辅助栈-auxiliary-stack&#34;&gt;&#xA;  方案一：辅助栈 (Auxiliary Stack)&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b9%e6%a1%88%e4%b8%80%e8%be%85%e5%8a%a9%e6%a0%88-auxiliary-stack&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;最直观的思路是设置一个辅助结构来同步记录最值。我们以“最大值”为例，引入一个辅助栈 &lt;code&gt;SMax&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;算法描述&#34;&gt;&#xA;  算法描述&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;State:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  DataStack: [Integer] // The primary storage&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  SMax:      [Integer] // Auxiliary stack to store the sequence of maximums&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这个方案中，逻辑如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Push&lt;/strong&gt;: 当元素入栈时，我们不仅将其压入数据栈；同时，比较该元素与 &lt;code&gt;SMax&lt;/code&gt; 栈顶元素。如果该元素大于等于 &lt;code&gt;SMax&lt;/code&gt; 栈顶元素（或者 &lt;code&gt;SMax&lt;/code&gt; 为空），则将该元素也压入 &lt;code&gt;SMax&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Pop&lt;/strong&gt;: 当元素出栈时，判断该元素是否等于 &lt;code&gt;SMax&lt;/code&gt; 的栈顶元素。如果相等，说明我们要弹出的正是当前的最大值，因此 &lt;code&gt;SMax&lt;/code&gt; 也要同步弹出栈顶。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;伪代码描述&#34;&gt;&#xA;  伪代码描述&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%aa%e4%bb%a3%e7%a0%81%e6%8f%8f%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Function Push(element):&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    DataStack.Push(element)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    // If element is new max, push to SMax&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    IF SMax.IsEmpty() OR element &amp;gt;= SMax.Top():&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        SMax.Push(element)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Function Pop():&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    value = DataStack.Pop()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    // If we are popping the current max, pop from SMax too&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    IF value == SMax.Top():&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        SMax.Pop()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    RETURN value&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Function GetMax():&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    RETURN SMax.Top()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;场景推演&#34;&gt;&#xA;  场景推演&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9c%ba%e6%99%af%e6%8e%a8%e6%bc%94&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;为了验证这个逻辑，我们以序列 &lt;code&gt;1, 3, 6, 1, 12, 512, 12, 5121, 121, 412&lt;/code&gt; 为例进行推演：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Trie树学习</title>
      <link>https://www.yeqown.xyz/2018/02/11/Trie%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sun, 11 Feb 2018 15:03:31 +0000</pubDate>
      <guid>https://www.yeqown.xyz/2018/02/11/Trie%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/</guid>
      <description>&lt;p&gt;Trie树(Retrieval Tree)又称前缀树，可以用来保存多个字符串，并且查找效率高。在trie中查找一个字符串的时间只取决于组成该串的字符数，与树的节点数无关。Trie树形状如下图：&#xA;&lt;img src=&#34;http://img.my.csdn.net/uploads/201209/10/1347267156_9178.jpg&#34; alt=&#34;Trie树&#34; /&gt;&lt;/p&gt;&#xA;&lt;!-- more --&gt;&#xA;&lt;h3 id=&#34;应用场景&#34;&gt;&#xA;  应用场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;词频统计（搜索引擎常用）&lt;/li&gt;&#xA;&lt;li&gt;前缀单词搜索&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;构造trie树&#34;&gt;&#xA;  构造Trie树&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9e%84%e9%80%a0trie%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;构造Trie树有如下几种方式（非全部）：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 结构1，简单且直观，但是空间闲置较多，利用率低下&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TrieNode&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;Char&lt;/span&gt;&#x9; &lt;span style=&#34;color:#66d9ef&#34;&gt;rune&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;Children&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;27&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;TrieNode&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 结构二 可变数组Trie树, 减少了闲置指针，但是只能通过遍历来获取下一状态，降低了查询效率&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TrieNode&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;Char&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;rune&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;Children&lt;/span&gt; []&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;TrieNode&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 结构3，双数组Trie树，空间和时间上耗费较为均衡，但是动态构建，解决冲突耗费时间较多&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TrieNode&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;Base&lt;/span&gt;  []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;Check&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;数组构造方式&#34;&gt;&#xA;  数组构造方式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e7%bb%84%e6%9e%84%e9%80%a0%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;这里选择双数组方式来实现Trie树。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;基于数组的实现方式，把trie看作一个DFA，树的每个节点对应一个DFA状态，每条从父节点指向子节点的有向边对应一个DFA变换。遍历从根节点开始，字符串的每个字符作为输入用来确定下一个状态，直到叶节点。 &amp;mdash;- 摘自参考资料，Trie数组实现原理&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.yeqown.xyz/images/trie_dfa.gif&#34; alt=&#34;数组Trie之DFA&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;关于双数组：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Base数组，表示后即节点的基地址的数组，叶子节点没有后继&lt;/li&gt;&#xA;&lt;li&gt;Check数组，用于检查&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;trie树应用之前缀搜索&#34;&gt;&#xA;  Trie树应用之前缀搜索&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#trie%e6%a0%91%e5%ba%94%e7%94%a8%e4%b9%8b%e5%89%8d%e7%bc%80%e6%90%9c%e7%b4%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;前缀搜索。也就是给一定的字符串，给出所有以该字符串开始的单词。譬如，Search(&amp;ldquo;go&amp;rdquo;)，得到[&amp;ldquo;go&amp;rdquo;, &amp;ldquo;golang&amp;rdquo;, &amp;ldquo;google&amp;rdquo;, &amp;hellip;]&lt;/p&gt;&#xA;&lt;h3 id=&#34;三种构造方式的优劣分析&#34;&gt;&#xA;  三种构造方式的优劣分析&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%89%e7%a7%8d%e6%9e%84%e9%80%a0%e6%96%b9%e5%bc%8f%e7%9a%84%e4%bc%98%e5%8a%a3%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;trie树数组trie树&#34;&gt;&#xA;  Trie树（数组Trie树）&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#trie%e6%a0%91%e6%95%b0%e7%bb%84trie%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;每个节点都含有26个字母指针，但并不是都会使用，内存利用率低。时间复杂度：O(k)， 空间复杂度：O(26^n)&lt;/p&gt;</description>
    </item>
    <item>
      <title>动态规划之字符串编辑距离</title>
      <link>https://www.yeqown.xyz/2018/02/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98-LD/</link>
      <pubDate>Sun, 11 Feb 2018 09:57:18 +0000</pubDate>
      <guid>https://www.yeqown.xyz/2018/02/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98-LD/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;&#xA;  问题描述&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;给定 2 个字符串 a, b. 编辑距离是将 a 转换为 b 的最少操作次数，操作只允许如下 3 种：&#xA;插入一个字符，例如：fj -&amp;gt; fxj&#xA;删除一个字符，例如：fxj -&amp;gt; fj&#xA;替换一个字符，例如：jyj -&amp;gt; fyj&lt;/p&gt;&#xA;&lt;p&gt;函数原型：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LevenshteinDis&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;str1&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;str2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- more --&gt;&#xA;&lt;h3 id=&#34;算法适用场景&#34;&gt;&#xA;  算法适用场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%97%e6%b3%95%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;拼写检查&lt;/li&gt;&#xA;&lt;li&gt;输入联想&lt;/li&gt;&#xA;&lt;li&gt;语音识别&lt;/li&gt;&#xA;&lt;li&gt;论文检查&lt;/li&gt;&#xA;&lt;li&gt;DNA分析&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;问题分析&#34;&gt;&#xA;  问题分析&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;!-- Q：为什么要用动态规划呢，其他算法不能解决这个问题嘛？&#xA;A：可以参考参考资料里面的分析，有别的算法（如分治）可以解决这个问题，但是介于时间和空间的耗费，动态规划更优。 --&gt;&#xA;&lt;p&gt;假定函数edit_dis(stra, strb)表示，stra到strb的编辑距离。算法问题可以分为四种情况：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;edit_dis(0, 0) = 0&lt;/li&gt;&#xA;&lt;li&gt;edit_dis(0, strb) = len(strb)&lt;/li&gt;&#xA;&lt;li&gt;edit_dis(stra, strb) = len(stra)&lt;/li&gt;&#xA;&lt;li&gt;edit_dis(stra, strb) = ?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;对于4th一般情况，没有办法直接给出求解方式，我们来分析edit_dis(stra+chara, strb+charb)可能的情况：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;stra能转成strb，那么只需要判断chara是不是等于charb (cur_cost = 0 if chara == charb else 1)&lt;/li&gt;&#xA;&lt;li&gt;stra+chara能转成strb, 那么要让stra + chara 转成strb+ charb, 只需要插入charb就行了&lt;/li&gt;&#xA;&lt;li&gt;如果stra 可以直接转成strb+charb，那么删除chara就可以转换成功了&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;综上的分析，可以得到如下DP公式：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
