<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Yeqown</title>
    <link>https://www.yeqown.xyz/categories/Algorithm/</link>
    <description>Recent content in Algorithm on Yeqown</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Fri, 05 Apr 2019 14:51:46 +0000</lastBuildDate>
    <atom:link href="https://www.yeqown.xyz/categories/Algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>介绍一下snowflake和rc4</title>
      <link>https://www.yeqown.xyz/2019/04/05/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bsnowflake%E5%92%8Crc4/</link>
      <pubDate>Fri, 05 Apr 2019 14:51:46 +0000</pubDate>
      <guid>https://www.yeqown.xyz/2019/04/05/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bsnowflake%E5%92%8Crc4/</guid>
      <description>&lt;p&gt;&lt;code&gt;snowflake&lt;/code&gt;是twitter公司开源的生成唯一ID的网络服务，具有很强的伸缩性，这里只取用生成唯一ID的算法部分。&#xA;&lt;code&gt;rc4&lt;/code&gt;（Rivest Cipher 4）是一种流加密算法，密钥长度可变，它的加解密使用相同的密钥，因此也属于对称加密算法。&lt;/p&gt;&#xA;&lt;!-- more --&gt;&#xA;&lt;h3 id=&#34;为啥要介绍这两种算法&#34;&gt;&#xA;  为啥要介绍这两种算法？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e5%95%a5%e8%a6%81%e4%bb%8b%e7%bb%8d%e8%bf%99%e4%b8%a4%e7%a7%8d%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;其一，&lt;code&gt;snowflake&lt;/code&gt;可以生成唯一ID，而相比与&lt;code&gt;UUID&lt;/code&gt;，&lt;code&gt;snowflake&lt;/code&gt;生成的ID更加“好用”，这个放在后面解释。&#xA;其二，&lt;code&gt;UUID&lt;/code&gt;和&lt;code&gt;snowflake&lt;/code&gt;虽然可以生成唯一ID，但是无法适用于所有场景，譬如说“生成推广码”。生成推广码的时候，希望尽可能短而精，很明显唯一ID都不太短。&lt;/p&gt;&#xA;&lt;h3 id=&#34;snowflake&#34;&gt;&#xA;  snowflake&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#snowflake&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;snowflake的唯一ID是一个64bit的int型数据，相较于UUID来说耗费空间更小，可以更方便的作为数据库主键来索引和排序。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.yeqown.xyz/images/snowflake.png&#34; alt=&#34;snowflake&#34; /&gt;&lt;/p&gt;&#xA;&lt;h6 id=&#34;生成过程&#34;&gt;&#xA;  生成过程：&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%9f%e6%88%90%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h6&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;置0不用&lt;/li&gt;&#xA;&lt;li&gt;timestamp（41bits）精确到ms。&lt;/li&gt;&#xA;&lt;li&gt;machine-id（10bits）该部分其实由datacenterId和workerId两部分组成，这两部分是在配置文件中指明的。datacenterId（5bits）方便搭建多个生成uid的service，并保证uid不重复。workerId（5bits）是实际server机器的代号，最大到32，同一个datacenter下的workerId是不能重复的。&lt;/li&gt;&#xA;&lt;li&gt;sequence-id(12bits)，该id可以表示4096个数字，它是在time相同的情况下，递增该值直到为0，即一个循环结束，此时便只能等到下一个ms到来，一般情况下4096/ms的请求是不太可能出现的，所以足够使用了。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h6 id=&#34;优势和缺陷&#34;&gt;&#xA;  优势和缺陷：&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%98%e5%8a%bf%e5%92%8c%e7%bc%ba%e9%99%b7&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h6&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;速度快，无依赖，原理和实现简单，也可以根据自己的需求做算法调整&lt;/li&gt;&#xA;&lt;li&gt;依赖机器时间，如果时间回拨可能导致重复的ID&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;rc4&#34;&gt;&#xA;  rc4&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#rc4&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;RC4加密算法也是一种基于密钥流的加密算法。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;首先，rc4根据明文和密钥生成的密钥流，其长度和明文的长度是相等的，也就是说明文的长度是500字节，那么密钥流也是500字节，这也是我们用来生成&lt;code&gt;推广码&lt;/code&gt;的原因之一了；其次，rc4是是对称加密完全可以通过密文得到明文，也就是说在生成码的时候把必要信息放在明文中，在使用密文的时候可以不用查库也能得到相关的信息，譬如用户ID，这是原因之二。&lt;/p&gt;&#xA;&lt;h6 id=&#34;使用场景&#34;&gt;&#xA;  使用场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h6&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;现在需要生成一种码，短小易记，且唯一，但并不需要大量。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;上述的snowflake和UUID都很容易实现唯一，但是短小就不符合要求了。因为并不需要大量生成这种码，因此我们考虑用&lt;code&gt;自增ID + RC4&lt;/code&gt;来实现：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;crypto/rc4&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;encoding/hex&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;log&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;cipher&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rc4&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;NewCipher&lt;/span&gt;([]byte(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;thisiskey&amp;#34;&lt;/span&gt;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;wrong with NewCipher: %v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;{}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []byte(&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Sprintf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%7d&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;dst&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;cipher&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;XORKeyStream&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;dst&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;dst&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 密文是不可读的字节流，这里采用hex编码&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#x9;&#x9;println(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;)         &lt;span style=&#34;color:#75715e&#34;&gt;// 形如：a09def6b6e4797&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;] = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;println(len(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;)) &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hex&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;EncodeToString&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;参考&#34;&gt;&#xA;  参考&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/twitter-archive/snowflake&#34;&gt;twitter-snowflake&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/bwmarrin/snowflake&#34;&gt;bwmarrin/snowflake&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/yeqown/snowflake&#34;&gt;yeqown/snowflake&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://juejin.im/entry/59b5ef585188257e8901487d&#34;&gt;关于snowflake的分析&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.kancloud.cn/db-design/mysql-dba/596722&#34;&gt;为什么推荐InnoDB引擎使用自增主键?&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Stack实现O(1)的Min和Max</title>
      <link>https://www.yeqown.xyz/2018/03/01/Stack%E5%AE%9E%E7%8E%B0O1%E7%9A%84Min%E5%92%8CMax/</link>
      <pubDate>Thu, 01 Mar 2018 16:26:05 +0000</pubDate>
      <guid>https://www.yeqown.xyz/2018/03/01/Stack%E5%AE%9E%E7%8E%B0O1%E7%9A%84Min%E5%92%8CMax/</guid>
      <description>&lt;p&gt;栈（Stack）Pop和Push操作只需要对栈顶元素进行操作，就不多加描述了。那么对于Max和Min操作，怎么保证O(1)的时间复杂度?最直接想到的就是设置两个标记位，最小值的最大值，在push和pop的时候更新两个值。那么怎么更新呢，怎么保证最大值和最小值弹出之后还能正确获取到当前所有元素中的最大值和最小值呢？请看下文：&lt;/p&gt;&#xA;&lt;!-- more --&gt;&#xA;&lt;h3 id=&#34;辅助最大值栈sm&#34;&gt;&#xA;  辅助最大值栈SM&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%be%85%e5%8a%a9%e6%9c%80%e5%a4%a7%e5%80%bc%e6%a0%88sm&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;算法描述&#34;&gt;&#xA;  算法描述&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Stack&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Struct&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SMax&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Stack&lt;/span&gt; = new(&lt;span style=&#34;color:#a6e22e&#34;&gt;Stack&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;push: 如果当前元素大于等于辅助栈的栈顶元素或者辅助栈为空，那么当前元素push到辅助栈中&lt;/li&gt;&#xA;&lt;li&gt;pop:  如果当前元素等于辅助栈的栈顶元素，那么从辅助栈中弹出当前元素&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;举个例子&#34;&gt;&#xA;  举个例子&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%be%e4%b8%aa%e4%be%8b%e5%ad%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;如果有1，3，6，1，12，512，12，5121，121，412数据放入栈中&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Step-1. 元素&lt;code&gt;1&lt;/code&gt;入栈，当前SM栈为空，SM栈也同步更新&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;Stack: 1&#xA;SMax: 1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Step-2. 元素&lt;code&gt;3&lt;/code&gt;入栈，&lt;code&gt;3&lt;/code&gt; &amp;gt; &lt;code&gt;1&lt;/code&gt;，SMax栈也同步更新&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;Stack: 1, 3&#xA;SMax: 1, 3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Step-3. 元素&lt;code&gt;6&lt;/code&gt;入栈，&lt;code&gt;6&lt;/code&gt;&amp;gt;&lt;code&gt;3&lt;/code&gt;，SMax栈也同步更新&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;Stack: 1, 3, 6&#xA;SMax: 1, 3, 6&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&amp;hellip;此处省略更多步骤&lt;/p&gt;&#xA;&lt;h3 id=&#34;最大值标记法&#34;&gt;&#xA;  最大值标记法&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%80%e5%a4%a7%e5%80%bc%e6%a0%87%e8%ae%b0%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;第一种方式利用辅助栈来标记当前最大值和上一个最大值，并利用栈来实现O(1)复杂度。但是根据上述的例子，可以看到如果插入的元素是依次增大，那么耗费2N+1空间才能实现栈的最大值和最小值在O(1)复杂度。现在介绍的方法，能够很好的减少空间耗费，并保证O(1)时间复杂度。&lt;/p&gt;&#xA;&lt;h4 id=&#34;算法描述-1&#34;&gt;&#xA;  算法描述&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0-1&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Stack&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// default = math.MinInt32&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;push: 将(&lt;code&gt;当前元素&lt;/code&gt;-&lt;code&gt;Max&lt;/code&gt;)放入栈中；如果&lt;code&gt;当前元素&lt;/code&gt;大于&lt;code&gt;Max&lt;/code&gt;，用&lt;code&gt;当前元素&lt;/code&gt;替换&lt;code&gt;Max&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;pop: &#x9;如果&lt;code&gt;栈顶元素&lt;/code&gt;&amp;gt;&lt;code&gt;0&lt;/code&gt;，弹出Max，用&lt;code&gt;Max&lt;/code&gt;-&lt;code&gt;栈顶元素&lt;/code&gt;替换&lt;code&gt;Max&lt;/code&gt;；否则弹出&lt;code&gt;Max&lt;/code&gt;+&lt;code&gt;栈顶元素&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;再举个例子&#34;&gt;&#xA;  再举个例子&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%86%8d%e4%b8%be%e4%b8%aa%e4%be%8b%e5%ad%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;如果有5, 23, 12, 499, 45, 20, 60入栈&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Step-1. 元素&lt;code&gt;5&lt;/code&gt;-Max入栈，&lt;code&gt;5&lt;/code&gt; &amp;gt; &lt;code&gt;math.MinInt32&lt;/code&gt;, 更新Max=5&lt;/p&gt;</description>
    </item>
    <item>
      <title>Trie树学习</title>
      <link>https://www.yeqown.xyz/2018/02/11/Trie%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sun, 11 Feb 2018 15:03:31 +0000</pubDate>
      <guid>https://www.yeqown.xyz/2018/02/11/Trie%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/</guid>
      <description>&lt;p&gt;Trie树(Retrieval Tree)又称前缀树，可以用来保存多个字符串，并且查找效率高。在trie中查找一个字符串的时间只取决于组成该串的字符数，与树的节点数无关。Trie树形状如下图：&#xA;&lt;img src=&#34;http://img.my.csdn.net/uploads/201209/10/1347267156_9178.jpg&#34; alt=&#34;Trie树&#34; /&gt;&lt;/p&gt;&#xA;&lt;!-- more --&gt;&#xA;&lt;h3 id=&#34;应用场景&#34;&gt;&#xA;  应用场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;词频统计（搜索引擎常用）&lt;/li&gt;&#xA;&lt;li&gt;前缀单词搜索&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;构造trie树&#34;&gt;&#xA;  构造Trie树&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9e%84%e9%80%a0trie%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;构造Trie树有如下几种方式（非全部）：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 结构1，简单且直观，但是空间闲置较多，利用率低下&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TrieNode&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;Char&lt;/span&gt;&#x9; &lt;span style=&#34;color:#66d9ef&#34;&gt;rune&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;Children&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;27&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;TrieNode&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 结构二 可变数组Trie树, 减少了闲置指针，但是只能通过遍历来获取下一状态，降低了查询效率&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TrieNode&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;Char&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;rune&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;Children&lt;/span&gt; []&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;TrieNode&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 结构3，双数组Trie树，空间和时间上耗费较为均衡，但是动态构建，解决冲突耗费时间较多&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TrieNode&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;Base&lt;/span&gt;  []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;Check&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;数组构造方式&#34;&gt;&#xA;  数组构造方式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e7%bb%84%e6%9e%84%e9%80%a0%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;这里选择双数组方式来实现Trie树。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;基于数组的实现方式，把trie看作一个DFA，树的每个节点对应一个DFA状态，每条从父节点指向子节点的有向边对应一个DFA变换。遍历从根节点开始，字符串的每个字符作为输入用来确定下一个状态，直到叶节点。 &amp;mdash;- 摘自参考资料，Trie数组实现原理&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.yeqown.xyz/images/trie_dfa.gif&#34; alt=&#34;数组Trie之DFA&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;关于双数组：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Base数组，表示后即节点的基地址的数组，叶子节点没有后继&lt;/li&gt;&#xA;&lt;li&gt;Check数组，用于检查&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;trie树应用之前缀搜索&#34;&gt;&#xA;  Trie树应用之前缀搜索&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#trie%e6%a0%91%e5%ba%94%e7%94%a8%e4%b9%8b%e5%89%8d%e7%bc%80%e6%90%9c%e7%b4%a2&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;前缀搜索。也就是给一定的字符串，给出所有以该字符串开始的单词。譬如，Search(&amp;ldquo;go&amp;rdquo;)，得到[&amp;ldquo;go&amp;rdquo;, &amp;ldquo;golang&amp;rdquo;, &amp;ldquo;google&amp;rdquo;, &amp;hellip;]&lt;/p&gt;&#xA;&lt;h3 id=&#34;三种构造方式的优劣分析&#34;&gt;&#xA;  三种构造方式的优劣分析&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%89%e7%a7%8d%e6%9e%84%e9%80%a0%e6%96%b9%e5%bc%8f%e7%9a%84%e4%bc%98%e5%8a%a3%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;h4 id=&#34;trie树数组trie树&#34;&gt;&#xA;  Trie树（数组Trie树）&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#trie%e6%a0%91%e6%95%b0%e7%bb%84trie%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;每个节点都含有26个字母指针，但并不是都会使用，内存利用率低。时间复杂度：O(k)， 空间复杂度：O(26^n)&lt;/p&gt;</description>
    </item>
    <item>
      <title>动态规划之字符串编辑距离</title>
      <link>https://www.yeqown.xyz/2018/02/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98-LD/</link>
      <pubDate>Sun, 11 Feb 2018 09:57:18 +0000</pubDate>
      <guid>https://www.yeqown.xyz/2018/02/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98-LD/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;&#xA;  问题描述&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;给定 2 个字符串 a, b. 编辑距离是将 a 转换为 b 的最少操作次数，操作只允许如下 3 种：&#xA;插入一个字符，例如：fj -&amp;gt; fxj&#xA;删除一个字符，例如：fxj -&amp;gt; fj&#xA;替换一个字符，例如：jyj -&amp;gt; fyj&lt;/p&gt;&#xA;&lt;p&gt;函数原型：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LevenshteinDis&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;str1&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;str2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- more --&gt;&#xA;&lt;h3 id=&#34;算法适用场景&#34;&gt;&#xA;  算法适用场景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%97%e6%b3%95%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;拼写检查&lt;/li&gt;&#xA;&lt;li&gt;输入联想&lt;/li&gt;&#xA;&lt;li&gt;语音识别&lt;/li&gt;&#xA;&lt;li&gt;论文检查&lt;/li&gt;&#xA;&lt;li&gt;DNA分析&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;问题分析&#34;&gt;&#xA;  问题分析&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;!-- Q：为什么要用动态规划呢，其他算法不能解决这个问题嘛？&#xA;A：可以参考参考资料里面的分析，有别的算法（如分治）可以解决这个问题，但是介于时间和空间的耗费，动态规划更优。 --&gt;&#xA;&lt;p&gt;假定函数edit_dis(stra, strb)表示，stra到strb的编辑距离。算法问题可以分为四种情况：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;edit_dis(0, 0) = 0&lt;/li&gt;&#xA;&lt;li&gt;edit_dis(0, strb) = len(strb)&lt;/li&gt;&#xA;&lt;li&gt;edit_dis(stra, strb) = len(stra)&lt;/li&gt;&#xA;&lt;li&gt;edit_dis(stra, strb) = ?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;对于4th一般情况，没有办法直接给出求解方式，我们来分析edit_dis(stra+chara, strb+charb)可能的情况：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;stra能转成strb，那么只需要判断chara是不是等于charb (cur_cost = 0 if chara == charb else 1)&lt;/li&gt;&#xA;&lt;li&gt;stra+chara能转成strb, 那么要让stra + chara 转成strb+ charb, 只需要插入charb就行了&lt;/li&gt;&#xA;&lt;li&gt;如果stra 可以直接转成strb+charb，那么删除chara就可以转换成功了&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;综上的分析，可以得到如下DP公式：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
