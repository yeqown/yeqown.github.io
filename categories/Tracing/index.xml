<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tracing on Yeqown</title>
    <link>https://www.yeqown.xyz/categories/Tracing/</link>
    <description>Recent content in Tracing on Yeqown</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 15 Dec 2021 16:16:05 +0800</lastBuildDate>
    <atom:link href="https://www.yeqown.xyz/categories/Tracing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Sentry&#43;OpenTelemetry前后端全链路打通总结</title>
      <link>https://www.yeqown.xyz/2021/12/15/Sentry-OpenTelemetry%E5%89%8D%E5%90%8E%E7%AB%AF%E5%85%A8%E9%93%BE%E8%B7%AF%E6%89%93%E9%80%9A%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 15 Dec 2021 16:16:05 +0800</pubDate>
      <guid>https://www.yeqown.xyz/2021/12/15/Sentry-OpenTelemetry%E5%89%8D%E5%90%8E%E7%AB%AF%E5%85%A8%E9%93%BE%E8%B7%AF%E6%89%93%E9%80%9A%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;自从微服务大行其道，容器化和k8s编排一统天下之后，&amp;ldquo;可观测性&amp;rdquo; 便被提出来。这个概念是指，对于应用或者容器的运行状况的掌控程度，其中分为了三个模块：&lt;code&gt;Metrics&lt;/code&gt;、&lt;code&gt;Tracing&lt;/code&gt;、&lt;code&gt;Logging&lt;/code&gt;。Metrics 指应用采集的指标；Tracing 指应用的追踪；Logging 指应用的日志。&lt;/p&gt;&#xA;&lt;p&gt;日志自不用多说，这是最原始的调试和数据采集能力。Metrics 比较火的方案就是 Prometheus + Grafana，思路就是通过应用内埋入SDK，选择 Pull 或者 Push 的方式将数据收集到 prometheus 中，然后通过 Grafana 实现可视化，当然这不是本文的重点就此略过。&lt;/p&gt;&#xA;&lt;p&gt;Tracing 也并不是可观测性提出后才诞生的概念，在微服务化的进程中就已经有Google的Dapper落地实践，并慢慢形成 OpenTracing 规范，这一规范又被多家第三方框架所支持，如 Jaeger、Zipkin 等。OpenTelemetry 就是结合了 OpenTracing + OpenCensus 规范，约定并提供完成的可观测性套件，只是目前（2021-12-15）稳定下来的只有 Tracing 这一部分而已。对 OpenTelemetry 发展历史感兴趣的可以自行了解。&lt;/p&gt;&#xA;&lt;h3 id=&#34;效果预览&#34;&gt;&#xA;  效果预览&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%88%e6%9e%9c%e9%a2%84%e8%a7%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;链路总览，包含了前端页面的生命周期 + 整个了链路采集到的Span聚合。&lt;/p&gt;&#xA;&lt;img src=&#34;https://pic4.zhimg.com/80/v2-7e517e59dc62fa60651234cda0b957ab_1440w.jpg&#34; width=&#34;100%&#34;&gt;&#xA;&lt;p&gt;前端页面指标采集概览，包含了该页面生命周期内的动作和日志等。&lt;/p&gt;&#xA;&lt;img src=&#34;https://pic3.zhimg.com/80/v2-5933ba9c680ae7acb11710228c50d6d2_1440w.jpg&#34; width=&#34;100%&#34;&gt;&#xA;&lt;p&gt;服务端链路细节，包含了服务端链路采集的标签和日志（事件）等信息。&lt;/p&gt;&#xA;&lt;img src=&#34;https://pic4.zhimg.com/80/v2-8bf65bad9e1b91d6f151d6786459ae77_1440w.jpg&#34; width=&#34;100%&#34;&gt;&#xA;&lt;p&gt;propagation兼容jaeger效果，保证jaeger侧链路完整，使用一致的 traceId检索。因为服务侧 sentry 是渐进更新的，因此没有接入的应用并不会展示在sentry侧， 等到完全更新后就会完整。&lt;/p&gt;&#xA;&lt;img src=&#34;https://pic3.zhimg.com/80/v2-4af53ee3436b5c7876fbb807a5124676_1440w.jpg&#34; width=&#34;100%&#34;&gt;&#xA;&lt;img src=&#34;https://pic1.zhimg.com/80/v2-f09a4d174ae96f8f4ddc52799421e914_1440w.jpg&#34; width=&#34;100%&#34;&gt;&#xA;&lt;h3 id=&#34;背景&#34;&gt;&#xA;  背景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%83%8c%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;目前运行中的链路追踪组件是采用 opentracing + jaeger 实现，这套方案唯二的不足就是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;opentracing 已经被 opentelemetry 兼容，且 opentelemetry 在可观测性上更全面，更灵活。&lt;/li&gt;&#xA;&lt;li&gt;浏览器侧支持不完善（可以参见 &lt;a href=&#34;https://github.com/jaegertracing/jaeger-client-javascript&#34;&gt;https://github.com/jaegertracing/jaeger-client-javascript&lt;/a&gt; ）【恰恰我司有这方面的需求 🤪】。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;前端采用 sentry 来采集前端页面数据（APP + WEB 都支持很好），因此才有了这么一个 前后端链路打通的需求。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Opentracing实战</title>
      <link>https://www.yeqown.xyz/2020/08/06/opentracing%E5%AE%9E%E6%88%98/</link>
      <pubDate>Thu, 06 Aug 2020 08:34:45 +0800</pubDate>
      <guid>https://www.yeqown.xyz/2020/08/06/opentracing%E5%AE%9E%E6%88%98/</guid>
      <description>&lt;h3 id=&#34;背景&#34;&gt;&#xA;  背景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%83%8c%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;在没有链路追踪系统的情况下，如果只要少数几个服务，或许还可以通过日志来排查定位问题。但是如果服务一旦超过10个，那么再想通过日志来定位分析问题将无比繁琐。&#xA;因为，你先要从大量的日志中删筛选出某次请求的日志数据，才能进行后续的定位分析。&#xA;倘若日志系统也不够完善，日志对于调试毫无帮助，那又得退回到最原始的方式，通过代码断点和增加日志，等待问题复现，或者通过肉眼检查代码。&#xA;不是说这种方式不行，而是大部分的程序员的业务需求比较紧张，这样的排查手段效率和收益远远达不到要求（如果你有时间，当我没说 🐶）。&lt;/p&gt;&#xA;&lt;p&gt;在实际场景中，我也遇到了这样的问题：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;日志系统里包含了过少的信息，对于调试几乎没有帮助 (几乎只有错误日志，缺少输出上下文的日志)。&lt;/li&gt;&#xA;&lt;li&gt;服务调用复杂，一个请求失败，只能透过错误码和错误信息进行判断是否存在调用失败的情况。&lt;/li&gt;&#xA;&lt;li&gt;调用链路复杂的情况下，想要对某个请求进行优化，无从下手。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这里只列举了跟&lt;code&gt;trace&lt;/code&gt;相关的一些原始场景，当然从上面的描述中还能发现&lt;code&gt;日志系统不够完善，对调试不友好&lt;/code&gt;，不过这里首要解决的问题是&lt;code&gt;链路追踪问题&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;如果对路链路追踪没有概念，还望自行查阅资料，这里不会过多介绍～&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;opentracing&#34;&gt;&#xA;  Opentracing&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#opentracing&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：Opentracing 是一套标准接口，而不是具体实现。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;这里就实战opentracing + jaeger 的链路追踪方案。其中 opentracing 是一套标准接口，而jaeger是包含了 opentracing 的实现的一套工具。&#xA;Trace链路简单示例如下：&lt;/p&gt;&#xA;&lt;img src=&#34;https://www.yeqown.xyz/images/tracing1_0.png&#34; /&gt;&#xA;&lt;h4 id=&#34;trace&#34;&gt;&#xA;  Trace&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#trace&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;描述在分布式系统中的一次&amp;quot;事务&amp;quot;。&lt;/p&gt;&#xA;&lt;h4 id=&#34;span&#34;&gt;&#xA;  Span&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#span&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;表示工作流的一部分的命名和定时操作。可以接受标签(Tag Key:Value)，以及附加到特定span实例的标注(Annotation)，如时间戳和结构化日志。&lt;/p&gt;&#xA;&lt;h4 id=&#34;spancontext&#34;&gt;&#xA;  SpanContext&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spancontext&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;追踪伴随分布式事务的信息，包括它通过网络或通过消息总线将服务传递给服务的时间。span上下文包含TraceId、SpanId和追踪系统需要传播到下游服务的其他数据。&lt;/p&gt;&#xA;&lt;h3 id=&#34;实战&#34;&gt;&#xA;  实战&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e6%88%98&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;这里我准备的是 Go 项目，服务之间通过&lt;code&gt;gRPC&lt;/code&gt;通信。链路如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                +-- process internal trace2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     +---&amp;gt; process internal trace1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     |                 +---&amp;gt; server-b trace&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;gRPC&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;entry&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;HTTP&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; ---&amp;gt; server-a trace--gRPC--|&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                       +---&amp;gt; server-c trace&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;gRPC&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                                   |&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                                   +----&amp;gt; process internal trace3&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从上图中可以明确，我们的目标是：实践&lt;code&gt;跨服务调用&lt;/code&gt;和&lt;code&gt;服务内部调用&lt;/code&gt;的链路追踪，配合jaeger我们还可以将链路信息可视化。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
