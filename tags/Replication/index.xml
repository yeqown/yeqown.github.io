<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Replication on Yeqown</title>
    <link>https://www.yeqown.xyz/tags/Replication/</link>
    <description>Recent content in Replication on Yeqown</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sun, 28 Sep 2025 14:59:43 +0800</lastBuildDate>
    <atom:link href="https://www.yeqown.xyz/tags/Replication/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kafka MirrorMaker2 从使用到迁移</title>
      <link>https://www.yeqown.xyz/2025/09/28/Apache-Kafka-MirrorMaker2%E4%BB%8E%E4%BD%BF%E7%94%A8%E5%88%B0%E8%BF%81%E7%A7%BB/</link>
      <pubDate>Sun, 28 Sep 2025 14:59:43 +0800</pubDate>
      <guid>https://www.yeqown.xyz/2025/09/28/Apache-Kafka-MirrorMaker2%E4%BB%8E%E4%BD%BF%E7%94%A8%E5%88%B0%E8%BF%81%E7%A7%BB/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;本文中使用的 Kafka 版本为 v3.3.2&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;&#xA;  引言&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%95%e8%a8%80&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Kafka MirrorMaker2 是 Kafka 官方提供的跨集群数据复制工具, 它是基于 Kafka Connect 框架构建的。MirrorMaker2 支持多种部署模式, 包括 Dedicated 模式和 Connect 集群模式，还有 standalone 模式。&lt;/p&gt;&#xA;&lt;p&gt;其中, Dedicated 模式有一个启动脚本 &lt;code&gt;kafka-mirror-maker.sh&lt;/code&gt;, 该脚本会启动一个独立的 MirrorMaker2 实例, 而不需要依赖 Kafka Connect 集群。Dedicated 模式适合小规模的复制任务, 但在大规模部署中, 它缺乏可扩展性和高可用性。&lt;/p&gt;&#xA;&lt;p&gt;相比之下, Connect 集群模式则是先搭建出一个 Kafka Connect 集群, 再提交 &lt;code&gt;MirrorMaker2&lt;/code&gt; 的 &lt;code&gt;MirrorSourceConnector&lt;/code&gt; 任务。这种模式下, 可以通过增加或减少 Connect 工作节点来动态调整复制任务的资源, 具备更好的弹性和容错能力。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;当然配置上也会更复杂一些, 需要管理 Connect 集群的配置和任务。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;那么, 如果我们已经在使用 Dedicated 模式部署了 MirrorMaker2, 但现在需要切换到 Connect 集群模式, 应该如何操作呢? 本文将介绍从 Dedicated 模式迁移到 Connect 集群模式时，怎么处理已经同步的 offset 进度, 以确保数据的一致性和连续性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis主从复制</title>
      <link>https://www.yeqown.xyz/2020/03/29/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Sun, 29 Mar 2020 09:45:19 +0800</pubDate>
      <guid>https://www.yeqown.xyz/2020/03/29/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</guid>
      <description>&lt;p&gt;redis主从复制是高可用方案中的一部分，那主从复制是如何进行的？又是如何实现的？怎么支撑了redis的高可用性？在主从模式下Master和Slave节点分别做了哪些事情？&lt;/p&gt;&#xA;&lt;h3 id=&#34;redis高可用方案是什么&#34;&gt;&#xA;  redis高可用方案是什么？&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redis%e9%ab%98%e5%8f%af%e7%94%a8%e6%96%b9%e6%a1%88%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;我理解的redis高可用的特点有：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;高QPS，主从 =&amp;gt; 读写分离&lt;/li&gt;&#xA;&lt;li&gt;高容量，集群分片 =&amp;gt; 高容量&lt;/li&gt;&#xA;&lt;li&gt;故障转移，sentinel =&amp;gt; 故障转移&lt;/li&gt;&#xA;&lt;li&gt;故障恢复，数据持久 =&amp;gt; 故障恢复 ～ 这里我简单的理解（RDB + AOF）= 故障恢复&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;主从复制&#34;&gt;&#xA;  主从复制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;redis 主从复制有两个版本：旧版（Ver2.8-），新版（Ver2.8+，增加PSYNC命令来解决旧版中的问题）&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;讨论复制时都需要考虑两种场景：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;场景1：从节点刚刚上线，需要去同步主节点时，这部分可以理解为 &lt;strong&gt;全量复制&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;场景2：从节点掉线，恢复上线后需要同步数据，使自己和主节点达到一致状态。这部分在旧版复制里等价于&lt;strong&gt;全量复制&lt;/strong&gt;，在新版里可以理解为&lt;strong&gt;增量复制&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;当然你肯定会想到如果主节点掉线，这时候会怎么样？这个场景当然也在redis高可用方案中，之时不是本文的重点，属于Sentinel机制的内容了。&lt;/p&gt;&#xA;&lt;h4 id=&#34;旧版主从复制&#34;&gt;&#xA;  旧版主从复制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a7%e7%89%88%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;前文说过了，旧版主从复制只有全量复制用于应付上述两个场景，因此下面的流程也只有一份：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;从服务器向主服务器发送sync命令。&lt;/li&gt;&#xA;&lt;li&gt;主服务器在收到sync命令之后，调用bgsave命令生成最新的rdb文件，将这个文件同步给从服务器，这样从服务器载入这个rdb文件之后，状态就会和主服务器执行bgsave命令时候的一致。&lt;/li&gt;&#xA;&lt;li&gt;主服务器将保存在命令缓冲区中的写命令同步给从服务器，从服务器执行这些命令，这样从服务器的状态就跟主服务器当前状态一致了。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;如果你不知道redis中还有个缓冲区的话，建议系统的了解下redis中缓冲区的设计。这里缓冲区特指命令缓冲区，后面还会讲到复制缓冲区。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;img src=&#34;https://www.yeqown.xyz/images/redis-mlcopy-1.svg&#34; height=&#34;300px&#34;/&gt;&#xA;&lt;p&gt;但是这样的实现在 &lt;strong&gt;场景2&lt;/strong&gt; 下的缺点很明显：如果说从节点断线后迅速上线，这段时间内的产生的写命令很少，却要&lt;strong&gt;全量复制&lt;/strong&gt;主库的数据，传输了大量重复数据。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;SYNC命令产生的消耗：&#xA;1. 主节点生成RDB，需要消耗大量的CPU，内存和磁盘IO&#xA;2. 网络传输大量字节数据，需要消耗主从服务器的网络资源&#xA;3. 从节点需要从RDB文件恢复，会造成阻塞无法接受客户端请求&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;优点就是：简单暴力。个人看来在redis架构中不合适的用法，不代表说实际场景中也一定不合适，简单暴力也是一个很大的优点。&lt;/p&gt;&#xA;&lt;h4 id=&#34;新版主从复制&#34;&gt;&#xA;  新版主从复制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b0%e7%89%88%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;新版的主从复制跟旧版的区别就在于：对场景2的优化。&lt;/p&gt;&#xA;&lt;p&gt;场景2的缺点上文已经提到过了，那么优化的方向就是**“尽量不使用全量复制；增加增量复制(PSYNC)的功能”**。为此还要解决下列问题：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果某个从节点断线了，重新上线该从节点如何知道自己是否应该全量还是增量复制呢？&lt;/li&gt;&#xA;&lt;li&gt;该从节点断线恢复后，又怎么知道自己缺失了哪些数据呢？&lt;/li&gt;&#xA;&lt;li&gt;主节点又如何补偿该从节点在断线期间丢失的那部分数据呢？旧版的复制除了RDB，还有从命令缓冲区中的写命令来保持数据一致。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;为此新版中使用了以下概念：&lt;/p&gt;&#xA;&lt;h5 id=&#34;运行id---runid&#34;&gt;&#xA;  运行ID - runid&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%90%e8%a1%8cid---runid&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h5&gt;&#xA;&lt;p&gt;每个redis服务器都有其runid，runid由服务器在启动时自动生成，主服务器会将自己的runid发送给从服务器，而从服务器会将主服务器的runid保存起来。从服务器redis断线重连之后进行同步时，就是根据runid来判断同步的进度：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果前后两次主服务器runid&lt;strong&gt;一致&lt;/strong&gt;，则认为这一次断线重连还是之前复制的主服务器，主服务器可以继续尝试部分同步操作。&lt;/li&gt;&#xA;&lt;li&gt;如果前后两次主服务器runid&lt;strong&gt;不相同&lt;/strong&gt;，则&lt;strong&gt;全同步流程&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h5 id=&#34;复制偏移量---offset&#34;&gt;&#xA;  复制偏移量 - offset&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%8d%e5%88%b6%e5%81%8f%e7%a7%bb%e9%87%8f---offset&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h5&gt;&#xA;&lt;p&gt;主从节点，分别会维护一个复制偏移量：&#xA;主服务器每次向从服务器同步了N字节数据之后，将修改自己的复制偏移量+N。从服务器每次从主服务器同步了N字节数据之后，将修改自己的复制偏移量+N。通过对比主从节点的偏移量很容易就可以发现，主从节点是否处于一致状态。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
