<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Im on Yeqown</title>
    <link>https://www.yeqown.xyz/tags/im/</link>
    <description>Recent content in Im on Yeqown</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 04 Dec 2019 18:37:31 +0800</lastBuildDate>
    <atom:link href="https://www.yeqown.xyz/tags/im/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>基于socket.io构建即时通讯系统</title>
      <link>https://www.yeqown.xyz/2019/12/04/%E5%9F%BA%E4%BA%8Esocket.io%E6%9E%84%E5%BB%BA%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 04 Dec 2019 18:37:31 +0800</pubDate>
      <guid>https://www.yeqown.xyz/2019/12/04/%E5%9F%BA%E4%BA%8Esocket.io%E6%9E%84%E5%BB%BA%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;本意在总结实现&lt;a href=&#34;github.com/yeqown/socket.io-app&#34;&gt;socket.io-app&lt;/a&gt;过程中的一些知识。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;背景&#34;&gt;&#xA;  背景&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%83%8c%e6%99%af&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;现需要替换公司的即时通信框架（之前用的是阿里云的微消息队列，优点在于：简单易接入，问题在于：对于人数和客户端状态感知不够准确，原因后面细说）。在框架选型的时候，基于应用场景（客户端有：小程序/nodeJS/浏览器），有三种方案：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;替换MQTT的架子，针对现有场景下的问题，选用一款更加可控的MQTT服务，如&lt;a href=&#34;https://www.emqx.io&#34;&gt;EMQX&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;li&gt;基于现有的技术栈，选择一款golang开发的开源框架，在此基础上进行开发，如&lt;a href=&#34;https://github.com/Terry-Mao/goim&#34;&gt;goim&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;li&gt;一个大众且稳定的开源框架，语言不限，如&lt;a href=&#34;https://github.com/socketio/socket.io&#34;&gt;socket.io&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;综合一系列因素（技术熟悉程度/star数/时间成本/金钱成本/运维成本）选择了&lt;code&gt;socket.io / JS&lt;/code&gt;🐶～&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;这里想推荐一下&lt;code&gt;goim&lt;/code&gt;给&lt;code&gt;golang&lt;/code&gt;程序猿。个人看法：goim对团队技术栈更友好；对分布式更友好；架构合理易于扩展；如有兴趣可以去看下：https://juejin.im/post/5cbb9e68e51d456e51614aab @tsingson 的解析，结合源码更容易理解上手。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;关于socketio的介绍&#34;&gt;&#xA;  关于socket.io的介绍&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b3%e4%ba%8esocketio%e7%9a%84%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;文档在此&lt;a href=&#34;https://socket.io/docs/&#34;&gt;socket.io&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;通信机制及特点&#34;&gt;&#xA;  通信机制及特点&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%9a%e4%bf%a1%e6%9c%ba%e5%88%b6%e5%8f%8a%e7%89%b9%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;特点&lt;/th&gt;&#xA;          &lt;th&gt;摘要&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;可用性&lt;/td&gt;&#xA;          &lt;td&gt;提供 long-polling 和 WebSocket 两种方式，可以自动升级，基于engine.io&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;自动重连&lt;/td&gt;&#xA;          &lt;td&gt;客户端会一直重连，直到再次链接上服务器&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;断线检测&lt;/td&gt;&#xA;          &lt;td&gt;客户端和服务端通过心跳维持长链接&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;二进制消息&lt;/td&gt;&#xA;          &lt;td&gt;任意被序列化的数据结构都可以传输&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;多路复用&lt;/td&gt;&#xA;          &lt;td&gt;对不同的Namespace,复用底层链接&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;内置Room概念&lt;/td&gt;&#xA;          &lt;td&gt;理解为聊天室和即可&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;基于websocket，但不互通&lt;/td&gt;&#xA;          &lt;td&gt;&lt;a href=&#34;https://github.com/socketio/socket.io-protocol&#34;&gt;https://github.com/socketio/socket.io-protocol&lt;/a&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;总结一下：socket.io 已经提供了即时通讯必要的基础，不用关心任何通讯相关的细节，开箱即用。&lt;/p&gt;&#xA;&lt;h4 id=&#34;分布式&#34;&gt;&#xA;  分布式&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e5%b8%83%e5%bc%8f&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&#xA;&lt;p&gt;确认socket.io已经提供了通讯基础，那么问题来了：单机性能有限，如何扩展到分布式呢?&#xA;socket.io的另一个优点&lt;code&gt;adapter&lt;/code&gt;机制让socket.io易于扩展，官方提供了&lt;code&gt;redis-adapter&lt;/code&gt;来支持消息分发。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;By running socket.io with the socket.io-redis adapter you can run multiple socket.io instances in different processes or servers that can all broadcast and emit events to and from each other.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
