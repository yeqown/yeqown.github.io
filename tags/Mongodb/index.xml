<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mongodb on Yeqown</title>
    <link>https://www.yeqown.xyz/tags/Mongodb/</link>
    <description>Recent content in Mongodb on Yeqown</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Thu, 16 Oct 2025 14:34:23 +0800</lastBuildDate>
    <atom:link href="https://www.yeqown.xyz/tags/Mongodb/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Debezium Mongodb Connector 增量快照使用</title>
      <link>https://www.yeqown.xyz/2025/10/16/debezium-Mongodb-Connector-%E5%A2%9E%E9%87%8F%E5%BF%AB%E7%85%A7%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 16 Oct 2025 14:34:23 +0800</pubDate>
      <guid>https://www.yeqown.xyz/2025/10/16/debezium-Mongodb-Connector-%E5%A2%9E%E9%87%8F%E5%BF%AB%E7%85%A7%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;之前的博客 &lt;a href=&#34;https://yeqown.xyz/2024/12/17/%E8%BF%91%E6%9C%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/#16-cdc-kafka-connect-mongodb-%e4%be%a7%e5%8f%8d%e5%a4%8d%e8%bf%9b%e8%a1%8c-%e5%bf%ab%e7%85%a7-%e5%af%bc%e8%87%b4%e6%95%b0%e6%8d%ae%e5%90%8c%e6%ad%a5%e5%bc%82%e5%b8%b8&#34;&gt;Kafka Connect Mongodb 反复快照 - 大数据集快照&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;本文中使用的 &lt;code&gt;MongodbSourceConnector&lt;/code&gt; 是 &lt;code&gt;io.debezium.connector.mongodb.MongoDbConnector 2.2.1.Final&lt;/code&gt;。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;机制简介&#34;&gt;&#xA;  机制简介&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%ba%e5%88%b6%e7%ae%80%e4%bb%8b&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;为了提供管理快照的灵活性，Debezium 包含一个补充快照机制，称为增量快照。增量快照依赖于 Debezium 机制向 Debezium 连接器发送信号。‼️ &lt;em&gt;&lt;strong&gt;增量快照运行时，不会阻塞变更流事件处理&lt;/strong&gt;&lt;/em&gt;。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;初始快照会先保存 change stream 的位点，开始执行全量快照，全量快照完成后，再从保存的位点开始增量处理变更事件。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;目前 Debezium 支持增量快照的连接器有：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Db2&lt;/li&gt;&#xA;&lt;li&gt;MariaDB (Technology Preview)&lt;/li&gt;&#xA;&lt;li&gt;MongoDB&lt;/li&gt;&#xA;&lt;li&gt;MySQL&lt;/li&gt;&#xA;&lt;li&gt;Oracle&lt;/li&gt;&#xA;&lt;li&gt;PostgreSQL&lt;/li&gt;&#xA;&lt;li&gt;SQL Server&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;发送这个信号支持多种方式，通过配置 &lt;code&gt;signal.enabled.channels&lt;/code&gt; 来指定，默认为 &lt;code&gt;source&lt;/code&gt;（也就是数据集合方式），可选值有：source、kafka、file 和 jmx：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;source 源数据库： 配置 &lt;code&gt;signal.data.collection&lt;/code&gt; 来指定集合&lt;/li&gt;&#xA;&lt;li&gt;kafka: 配置 &lt;code&gt;signal.kafka.topic&lt;/code&gt; 来指定 topic&lt;/li&gt;&#xA;&lt;li&gt;file: 配置 &lt;code&gt;signal.file&lt;/code&gt; 来指定文件路径，写入文件的格式数据为 JSON，字段取值参考下面的表格。&lt;/li&gt;&#xA;&lt;li&gt;jmx: 启用 &lt;code&gt;JMX MBean Server&lt;/code&gt; 来暴露 signaling bean&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;需要启用增量快照时，只需要向特定方式中写入数据即可。如果是 source 只需要向数据库中插入一条数据，如果是 kafka 那么则是投递一条消息。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kafka &#43; Mongodb 通信协议纪要</title>
      <link>https://www.yeqown.xyz/2025/04/24/kafka-mongodb%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%BA%AA%E8%A6%81/</link>
      <pubDate>Thu, 24 Apr 2025 14:06:44 +0800</pubDate>
      <guid>https://www.yeqown.xyz/2025/04/24/kafka-mongodb%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%BA%AA%E8%A6%81/</guid>
      <description>&lt;p&gt;Kafka 和 MongoDB 是目前使用比较广泛的消息队列和数据库，在之前的很长时间里对这两个软件系统的理解都停留在概念和使用上，直到最近遇到一个“诡异”的问题，已有的经验和调试方法无法定位时，最终尝试了下抓包分析才最终定位到问题的根源。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&#xA;使用 sarama 编写了一个 kafka 消费者组，这里不同寻常的地方在于：手动提交 + 批量消费。遇到的问题：某些分区消费进度无法成功提交，但是消息是消费成功的。出现这种情况的分区没有规律，触发 rebalance 后 “故障分区” 有概率会发生变化。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;分析/定位&lt;/strong&gt;：这里很明显的问题在于手动提交 offset 为什么不成功？从实现来说，提交 offset 的逻辑跟分区没有关系是一致，那这种不确定性故障时从哪儿来的？而且还和 rebalance 相关。&#xA;梳理下 kafka 客户端消费提交涉及到的操作：&lt;code&gt;Fetch&lt;/code&gt;, &lt;code&gt;OffsetCommit&lt;/code&gt;, 但是消费是正常的，那么只需要抓包分析 &lt;code&gt;OffsetCommit&lt;/code&gt; 就可以知道 offset 提交存在什么问题。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;：&#xA;通过抓包一切都明朗了：出现问题的分区同时有多个 OffsetCommit 请求，且其中有的请求提交的 offset 一致停留在一个 “旧的” 位置，不会更新，这样就缩小了范围：程序提交 offset 逻辑异常。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;img src=&#34;https://www.yeqown.xyz/images/mongo-kafka-protocol/protocol-concept-illustration.jpeg&#34; width=&#34;100%&#34; /&gt;&#xA;&lt;h2 id=&#34;kafka-协议&#34;&gt;&#xA;  KAFKA 协议&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#kafka-%e5%8d%8f%e8%ae%ae&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Kafka 协议是基于 TCP/IP 协议的二进制协议。其结构组成如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; RequestOrResponse {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    RequestResponseHeader requestResponseHeader; &lt;span style=&#34;color:#75715e&#34;&gt;// uint32 messageLength;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    SpecificRequestOrResponseHeader body; &lt;span style=&#34;color:#75715e&#34;&gt;// 格式取决于具体的请求和响应，比如：RequestV1Header&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; RequestV1Header {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  int16 apiKey;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  int16 apiVersion;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  int32 correlationId;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  string clientId;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;协议结构&#34;&gt;&#xA;  协议结构&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8d%8f%e8%ae%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://kafka.apache.org/protocol.html#protocol_messages&#34;&gt;https://kafka.apache.org/protocol.html#protocol_messages&lt;/a&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
